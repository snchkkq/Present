<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I Love You</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      will-change: contents;
    }

    #intro {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 50% 40%, rgba(80, 5, 30, 0.60), rgba(0, 0, 0, 1) 58%);
      transition: opacity 480ms ease;
    }

    #intro.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #intro.exiting {
      pointer-events: none;
    }

    #startBtn {
      border: 0;
      background: transparent;
      color: #ff4488;
      font-family: 'Georgia', serif;
      font-size: clamp(22px, 3.8vw, 34px);
      letter-spacing: 0.08em;
      line-height: 1.2;
      cursor: pointer;
      text-align: center;
      text-shadow:
        0 0 14px rgba(255,30,120, 0.90),
        0 0 30px rgba(220,20,80, 0.70),
        0 0 55px rgba(180,10,60, 0.45);
      animation: introPulse 1900ms ease-in-out infinite;
    }

    #intro.exiting #startBtn {
      animation: introExit 540ms cubic-bezier(.2, .9, .2, 1) forwards;
    }

    #intro.exiting {
      animation: introFade 420ms ease forwards 180ms;
    }

    #startBtn .heart {
      display: block;
      font-size: clamp(42px, 8vw, 68px);
      margin-bottom: 10px;
    }

    #startBtn .label {
      display: block;
      font-size: clamp(18px, 2.8vw, 28px);
    }

    @keyframes introPulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 0.9;
      }

      50% {
        transform: scale(1.04);
        opacity: 1;
      }
    }

    @keyframes introExit {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      34% {
        transform: scale(1.11);
        opacity: 1;
      }

      100% {
        transform: scale(0.78);
        opacity: 0;
      }
    }

    @keyframes introFade {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    #txt {
      position: fixed;
      bottom: 60px;
      width: 100%;
      text-align: center;
      font-family: 'Georgia', serif;
      font-style: italic;
      font-weight: 300;
      font-size: clamp(22px, 3.5vw, 42px);
      letter-spacing: 0.22em;
      color: rgba(255,80,150, 0);
      pointer-events: none;
      white-space: nowrap;
    }

    #txt .word {
      display: inline-block;
      color: rgba(255,100,165, 0.99);
      opacity: 0;
      transform: translateY(2px);
      filter: blur(1px);
      text-shadow:
        0 0 14px rgba(255,40,120, 0.80),
        0 0 30px rgba(220,20,80, 0.60),
        0 0 5px rgba(255,100,160, 0.50);
      transition: opacity 460ms ease, transform 460ms ease, filter 460ms ease;
    }

    #txt .word.visible {
      opacity: 1;
      transform: translateY(0);
      filter: blur(0);
    }

    /* Особое выделение "I Love You" — светлее, с усиленным свечением */
    #txt .word.highlight {
      color: rgba(255, 255, 255, 1);
      font-size: 1.18em;
      letter-spacing: 0.28em;
      text-shadow:
        0 0 20px rgba(255, 120, 180, 1.00),
        0 0 45px rgba(255,  50, 140, 0.80),
        0 0 80px rgba(220,  20,  90, 0.50),
        0 0 4px rgba(255, 255, 255, 0.90);
    }

    #txt::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%) scaleX(0.25);
      transform-origin: center;
      bottom: -8px;
      width: min(380px, 72vw);
      height: 2px;
      background: linear-gradient(90deg, rgba(220,20,80, 0), rgba(255,60,130, 1.00), rgba(220,20,80, 0));
      filter: drop-shadow(0 0 8px rgba(255,40,120, 0.90));
      opacity: 0;
    }

    #txt.line-on::after {
      animation: lineIn 850ms cubic-bezier(.2, .9, .2, 1) forwards, linePulse 2600ms ease-in-out infinite 850ms;
    }

    @keyframes lineIn {
      from {
        opacity: 0;
        transform: translateX(-50%) scaleX(0.25);
        filter: drop-shadow(0 0 2px rgba(180,40,90, 0.30));
      }

      to {
        opacity: 0.9;
        transform: translateX(-50%) scaleX(1);
        filter: drop-shadow(0 0 10px rgba(235,90,140, 0.85));
      }
    }

    @keyframes linePulse {

      0%,
      100% {
        opacity: 0.88;
        filter: drop-shadow(0 0 10px rgba(210,60,110, 0.82));
      }

      50% {
        opacity: 1;
        filter: drop-shadow(0 0 14px rgba(235,90,140, 0.92));
      }
    }

    @media (max-width: 520px) {
      #txt {
        letter-spacing: 0.15em;
      }
    }

    #prelude {
      position: fixed;
      inset: 0;
      z-index: 15;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 280ms ease;
    }

    #prelude.show {
      opacity: 1;
    }

    #prelude.done {
      opacity: 0;
    }

    #prelude .word {
      display: inline-block;
      margin: 0 0.18em;
      font-family: 'Georgia', serif;
      font-size: clamp(26px, 5.2vw, 56px);
      font-style: italic;
      color: rgba(255,80,140, 0.99);
      text-shadow:
        0 0 14px rgba(255,30,100, 0.80),
        0 0 28px rgba(220,20,80, 0.55);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 600ms ease, transform 600ms ease;
      white-space: nowrap;
    }

    #prelude .word.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Быстрое плавное исчезновение */
    #prelude .word.fadeout,
    #prelude2 .word.fadeout {
      opacity: 0 !important;
      transform: translateY(-6px) !important;
      transition: opacity 180ms ease-in, transform 180ms ease-in !important;
    }

    /* Состояние visible+fadeout — нужно для корректного триггера анимации */
    #prelude .word.visible.fadeout,
    #prelude2 .word.visible.fadeout {
      opacity: 0 !important;
      transform: translateY(-6px) !important;
    }

    #prelude .word.accent,
    #prelude2 .word.accent {
      color: rgba(255, 255, 255, 1);
      letter-spacing: 0.12em;
      text-shadow:
        0 0 18px rgba(255, 140, 200, 1.00),
        0 0 40px rgba(255,  50, 140, 0.85),
        0 0 70px rgba(220,  20,  90, 0.55),
        0 0 4px rgba(255, 255, 255, 0.95);
      position: relative;
    }

    #prelude .word.accent::after,
    #prelude2 .word.accent::after {
      content: "";
      position: absolute;
      left: 8%;
      right: 8%;
      bottom: -0.14em;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(220,20,80, 0), rgba(255,140,210, 1.00), rgba(220,20,80, 0));
      box-shadow: 0 0 8px rgba(255,160,200, 0.85);
      opacity: 0.95;
    }

    #prelude2 {
      position: fixed;
      inset: 0;
      z-index: 15;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 280ms ease;
    }

    #prelude2.show {
      opacity: 1;
    }

    #prelude2.done {
      opacity: 0;
    }

    #prelude2 .word {
      display: inline-block;
      margin: 0 0.18em;
      font-family: 'Georgia', serif;
      font-size: clamp(26px, 5.2vw, 56px);
      font-style: italic;
      color: rgba(255,80,140, 0.99);
      text-shadow:
        0 0 14px rgba(255,30,100, 0.80),
        0 0 28px rgba(220,20,80, 0.55);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 600ms ease, transform 600ms ease;
      white-space: nowrap;
    }

    #prelude2 .word.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Каждая часть прелюди — отдельный центрированный блок */
    #prelude-part1, #prelude-part2,
    #prelude2-part1, #prelude2-part2 {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      text-align: center;
    }

    /* Часть 2 скрыта по умолчанию — управляется через слова .visible */
    #prelude-part2, #prelude2-part2 {
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="intro">
    <button id="startBtn" type="button" aria-label="Start animation">
      <span class="heart">❤️</span>
      <span class="label">Click me</span>
    </button>
  </div>
  <div id="prelude" aria-hidden="true">
    <div id="prelude-part1">
      <span class="word p1-part1" data-delay="0">This</span>
      <span class="word p1-part1" data-delay="560">is</span>
      <span class="word p1-part1" data-delay="1120">all</span>
      <span class="word p1-part1" data-delay="1680">for</span>
    </div>
    <div id="prelude-part2">
      <span class="word accent p1-part2" data-delay="0">You</span>
    </div>
  </div>
  <div id="prelude2" aria-hidden="true">
    <div id="prelude2-part1">
      <span class="word p2-part1" data-delay="50">You</span>
      <span class="word p2-part1" data-delay="200">are</span>
      <span class="word p2-part1" data-delay="850">my</span>
      <span class="word p2-part1" data-delay="1300">beautiful</span>
    </div>
    <div id="prelude2-part2">
      <span class="word accent p2-part2" data-delay="0">Shayla</span>
    </div>
  </div>
  <canvas id="c"></canvas>
  <div id="txt">
    <!-- data-delay = мс от момента TEXT_START до появления слова -->
    <span class="word highlight" data-delay="0">I</span>
    <span class="word highlight" data-delay="1850">Love</span>
    <span class="word highlight" data-delay="3500">You</span>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // Mobile optimisation: cap pixel ratio to avoid 3x rendering on iPhone
    const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const DPR = IS_MOBILE ? Math.min(window.devicePixelRatio || 1, 1.5) : (window.devicePixelRatio || 1);

    let W = 0;
    let H = 0;
    let cx = 0;
    let cy = 0;
    let sc = 0;

    // Minimal controls: only delay + speed for each animation block.
    const ANIM = {
      contour: {
        delay: 0.27, // seconds before contour starts drawing
        speed: 0.26,  // drawing speed (higher = faster)
        glow: 5   // brightness of the neon glow after contour is complete (0..1)
      },
      network: {
        delay: 8.5,
        speed: 5,
        bfsSpeed: 1.0  // скорость BFS-волны (выше = быстрее, 0.5 = медленнее, 2.0 = вдвое быстрее)
      },
      words: {
        delay: 13.5,
        speed: 1
      },
      line: {
        delay: 0.5,
        speed: 0.05
      },
      sweep: {
        delay: -7,      // seconds after line before sweep starts
        speed: 40,       // speed of the existing orb sweep
        sweepSpeed: 7, // speed of the white contour sweep (cycles per second)
      },
      preludeFirst: {
        delay: 8.9,
        speed: 1,
        interval: 560,
        wordDelay: 0,
        part1HideAfter: 250,   // мс после последнего слова → начинается fade-out (0.2 сек интервал)
        part2ShowAfter: 150,   // мс после начала fade-out → появляется "You" (пока часть1 исчезает)
        part2HideAfter: 1200,
      },
      preludeSecond: {
        delay: 17.60,
        speed: 1,
        interval: 560,
        wordDelay: 0,
        part1HideAfter: 300,   // 0.1 сек интервал
        part2ShowAfter: 180,
        part2HideAfter: 1200,
      },
      iLoveYou: {
        // data-delay на каждом слове управляет задержкой (мс от TEXT_START)
        // Здесь можно задать базовую задержку перед первым словом
        baseDelay: 0,  // мс дополнительной задержки перед "I"
      },
      main: {
        delay: 22.15,
        speed: 0.74
      }
    };
    window.ANIM = ANIM;

    const INTERIOR_COUNT = IS_MOBILE ? 340 : 700;
    const CONTOUR_COUNT = IS_MOBILE ? 180 : 260;
    const BIRTH_DUR = 0.25 / Math.max(0.1, ANIM.contour.speed);
    const SPRING = 10.5;
    const DAMPING = 0.86;
    const CONTOUR_START = ANIM.contour.delay;
    const CONTOUR_STEP = 0.012 / Math.max(0.1, ANIM.contour.speed);
    const INTERIOR_START = 1.35;
    const CONTOUR_LINE_ALPHA = 0.62;

    const particles = [];
    const boundary = [];
    let heartClipPath = null;
    const links = [];
    const LINK_DIST = 68;
    const LINK_DIST_SQ = LINK_DIST * LINK_DIST;
    const MIN_LINKS_PER_NODE = 2;
    const MAX_LINKS_PER_NODE = 6;
    const LINK_ALPHA_SMOOTH = 9;
    const LINK_WOBBLE = 4.5;
    const LINK_FLOW_SPEED = 9.0;
    const LINK_DRIFT = 2.4;
    const DEPTH_POINT_SCALE = [0.72, 1.0, 1.42];
    const DEPTH_POINT_ALPHA = [0.45, 0.95, 1.32];
    const DEPTH_GLOW_ALPHA = [0.05, 0.15, 0.34];
    const DEPTH_LINK_ALPHA = [0.46, 1.02, 1.48];
    const DEPTH_LINK_WIDTH = [0.72, 1.08, 1.5];
    let contourStartIndex = 0;
    const BND_FIXED = [];
    let BND_TOP_IDX = 0;

    function pickDepthLayer() {
      const r = Math.random();
      if (r < 0.34) return 0; // far
      if (r < 0.77) return 1; // mid
      return 2; // front
    }

    function hx(t) {
      return 16 * Math.pow(Math.sin(t), 3);
    }

    function hy(t) {
      return -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
    }

    function resize() {
      const cssW = window.innerWidth;
      const cssH = window.innerHeight;
      W = canvas.width = Math.round(cssW * DPR);
      H = canvas.height = Math.round(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      cx = cssW / 2;
      cy = cssH / 2 - 70;
      // Heart formula spans ±16 units wide and ~18 units tall.
      // Cap sc so the heart fits within the screen with some padding.
      const scByW = (cssW * 0.46) / 16;
      const scByH = (cssH * 0.44) / 18;
      sc = Math.min(scByW, scByH);
      buildHeart();
      resetAnimation();
    }

    function buildHeart() {
      boundary.length = 0;
      const HEART_SEGMENTS = 900;
      for (let i = 0; i < HEART_SEGMENTS; i++) {
        const t = (i / HEART_SEGMENTS) * Math.PI * 2;
        boundary.push({ x: cx + hx(t) * sc, y: cy + hy(t) * sc });
      }

      // Fixed boundary for stable contour drawing (not affected by particle movement)
      BND_FIXED.length = 0;
      for (let i = 0; i < boundary.length; i++) BND_FIXED.push({ x: boundary[i].x, y: boundary[i].y });
      // BND_TOP_IDX is set after contourStartIndex is computed below
      heartClipPath = new Path2D();
      heartClipPath.moveTo(boundary[0].x, boundary[0].y);
      for (let i = 1; i < boundary.length; i++) {
        heartClipPath.lineTo(boundary[i].x, boundary[i].y);
      }
      heartClipPath.closePath();

      particles.length = 0;

      const pairCount = Math.floor(INTERIOR_COUNT / 2);
      for (let i = 0; i < pairCount; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * 0.998;
        const sx = hx(t) * sc * r;
        const txR = cx + Math.abs(sx);
        const txL = cx - Math.abs(sx);
        const ty = cy + hy(t) * sc * r;
        // Uniform spawn: частицы появляются равномерно в пределах WAVE_DUR
        const spawnAt = Math.random() * WAVE_DUR;
        const size = 1.05 + Math.random() * 1.35;
        const phase = Math.random() * Math.PI * 2;
        const pulse = 0.5 + Math.random() * 0.9;
        const depth = pickDepthLayer();

        particles.push({
          x: txR,
          y: ty,
          tx: txR,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt,
          isContour: false,
          size,
          phase,
          pulse,
          mirrorSign: 1,
          depth
        });

        particles.push({
          x: txL,
          y: ty,
          tx: txL,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt,
          isContour: false,
          size,
          phase,
          pulse,
          mirrorSign: -1,
          depth
        });
      }

      if (INTERIOR_COUNT % 2 === 1) {
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * 0.998;
        const tx = cx;
        const ty = cy + hy(t) * sc * r;
        const spawnAt = Math.random() * WAVE_DUR;
        particles.push({
          x: tx,
          y: ty,
          tx,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt,
          isContour: false,
          size: 1.1 + Math.random() * 1.15,
          phase: Math.random() * Math.PI * 2,
          pulse: 0.55 + Math.random() * 0.8,
          mirrorSign: 0,
          depth: 1
        });
      }

      // Build contour points with uniform arc-length spacing.
      const closed = boundary.slice();
      closed.push(boundary[0]);
      const cumulative = new Array(closed.length).fill(0);
      for (let i = 1; i < closed.length; i++) {
        const dx = closed[i].x - closed[i - 1].x;
        const dy = closed[i].y - closed[i - 1].y;
        cumulative[i] = cumulative[i - 1] + Math.hypot(dx, dy);
      }
      const totalLen = cumulative[cumulative.length - 1] || 1;

      let seg = 1;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const targetLen = (i / CONTOUR_COUNT) * totalLen;
        while (seg < cumulative.length - 1 && cumulative[seg] < targetLen) seg++;

        const l0 = cumulative[seg - 1];
        const l1 = cumulative[seg];
        const t = l1 > l0 ? (targetLen - l0) / (l1 - l0) : 0;
        const a = closed[seg - 1];
        const b = closed[seg];
        const tx = a.x + (b.x - a.x) * t;
        const ty = a.y + (b.y - a.y) * t;

        particles.push({
          x: tx,
          y: ty,
          tx,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt: CONTOUR_START + i * CONTOUR_STEP,
          isContour: true,
          size: 1.25 + Math.random() * 0.95,
          phase: 0,
          pulse: 0,
          mirrorSign: 0,
          depth: 2
        });
      }

      // Find TOP notch of heart = minimum y near cx (the dip between the two lobes)
      // t = PI gives the bottom tip, t = PI/2 and t = 3PI/2 give the lobes
      // The notch between lobes is near t=0 where hx=0 and hy is local min
      // Find by scanning: smallest y value among contour particles near cx
      let bestNotchScore = Infinity;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        // score = y value + penalty for being far from cx (finds top-center notch)
        const score = p.ty + Math.abs(p.tx - cx) * 1.5;
        if (score < bestNotchScore) {
          bestNotchScore = score;
          contourStartIndex = i;
        }
      }

      // Reveal contour symmetrically from the top notch to both sides.
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        const cw = (i - contourStartIndex + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ccw = (contourStartIndex - i + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ring = Math.min(cw, ccw);
        p.spawnAt = CONTOUR_START + ring * CONTOUR_STEP;
      }

      // Sync BND_TOP_IDX with contourStartIndex
      // The contour particle at contourStartIndex has target tx,ty — find closest BND_FIXED point
      {
        const refP = particles[INTERIOR_COUNT + contourStartIndex];
        let bstD = Infinity;
        for (let i = 0; i < BND_FIXED.length; i++) {
          const dx = BND_FIXED[i].x - refP.tx;
          const dy = BND_FIXED[i].y - refP.ty;
          const d = dx * dx + dy * dy;
          if (d < bstD) { bstD = d; BND_TOP_IDX = i; }
        }
      }

      initInteriorNetwork();
    }

    const WAVE_START = 0.3;
    const WAVE_DUR = 7.4 / Math.max(0.1, ANIM.network.speed);
    const NETWORK_START = ANIM.network.delay;
    const NETWORK_REVEAL_START = NETWORK_START + 0.1;
    const NETWORK_REVEAL_DUR = 0.85 / Math.max(0.1, ANIM.network.speed);

    // BFS wave data — populated in initInteriorNetwork after links are built
    const bfsOrder = [];        // particle indices in BFS visit order (interior only)
    const bfsParentOf = {};     // bfsParentOf[particleIdx] = parentParticleIdx
    const bfsTriggerTime = {};  // bfsTriggerTime[particleIdx] = animElapsed when ray arrives
    let bfsMaxDepth = 1;
    let bfsReady = false;
    // Total duration of the BFS wave spreading across the heart
    const BFS_TOTAL_DUR = 4.0 / Math.max(0.1, ANIM.network.bfsSpeed);
    // Active rays being drawn: { fromIdx, toIdx, startTime, dur, done }
    const activeRays = [];
    const TEXT_START = ANIM.words.delay;
    const NEON_SPEED = ANIM.sweep.speed;
    const NEON_TAIL_STEPS = 74;
    const NEON_TAIL_SPACING = 0.9;
    const CONTOUR_THREAD_ALPHA = 0.78;

    function ease(t) {
      return 1 - Math.pow(1 - Math.min(1, Math.max(0, t)), 3);
    }

    const txtEl = document.getElementById('txt');
    const wordEls = txtEl.querySelectorAll('.word');
    const preludeEl = document.getElementById('prelude');
    const preludeWords = preludeEl.querySelectorAll('.word');
    const prelude2El = document.getElementById('prelude2');
    const prelude2Words = prelude2El.querySelectorAll('.word');
    const introEl = document.getElementById('intro');
    const startBtn = document.getElementById('startBtn');
    const bgMusic = new Audio('music/post malone & swae lee - Sunflower (sped up + reverb).mp3');
    const wordBursts = [];
    const dustParticles = [];
    const DUST_PER_WORD = 95;
    const WORD_STAGGER = 0.42 / Math.max(0.1, ANIM.words.speed);
    const DUST_DUR = 1.05 / Math.max(0.1, ANIM.words.speed);
    const DUST_START_JITTER_MAX = 0.22 / Math.max(0.1, ANIM.words.speed);
    const DUST_LIFE_MAX_FACTOR = 1.12;
    const PRELUDE_WORDS_START_AT_SEC = ANIM.preludeFirst.delay;
    const PRELUDE2_WORDS_START_AT_SEC = ANIM.preludeSecond.delay;
    const MAIN_ANIMATION_START_AT_SEC = ANIM.main.delay;
    const LINE_AFTER_LAST_WORD_SEC = ANIM.line.delay;
    const LINE_IN_DUR_SEC = 0.85 / Math.max(0.1, ANIM.line.speed);
    const NEON_AFTER_LINE_SEC = ANIM.sweep.delay;
    const MAIN_TIME_SCALE = Math.max(0.2, ANIM.main.speed);

    let physicsAccumulator = 0;
    const PHYSICS_STEP = 1 / 60;
    let start = 0;
    let last = 0;
    let textStarted = false;
    let started = false;
    let startPending = false;
    let lineStartAt = Infinity;
    let contourNeonStartAt = Infinity;
    bgMusic.loop = false;
    bgMusic.volume = 0.62;

    function resetAnimation() {
      start = Date.now();
      last = start;
      textStarted = false;
      lineStartAt = Infinity;
      contourNeonStartAt = Infinity;
      wordBursts.length = 0;
      dustParticles.length = 0;
      activeRays.length = 0;
      // Clear only runtime trigger times (re-scheduled each run), keep bfsParentOf (static tree)
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];
      txtEl.classList.remove('line-on');
      wordEls.forEach((w) => {
        w.classList.remove('visible');
      });

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        // Interior particles stay at their target position (invisible until BFS reveals them)
        // Contour particles spring in from center
        if (!p.isContour && i < INTERIOR_COUNT) {
          p.x = p.tx;
          p.y = p.ty;
        } else {
          p.x = cx + (p.tx - cx) * 0.08;
          p.y = cy + (p.ty - cy) * 0.08;
        }
        p.vx = 0;
        p.vy = 0;
        p.alpha = 0;
        p.born = false;
        p.bornTime = 0;
      }
    }

    function startText(elapsed) {
      textStarted = true;
      prepareWordBursts(elapsed);
    }

    function prepareWordBursts(startElapsed) {
      wordBursts.length = 0;
      dustParticles.length = 0;

      wordEls.forEach((el, idx) => {
        const rect = el.getBoundingClientRect();
        const padX = Math.max(6, rect.width * 0.08);
        const padY = Math.max(4, rect.height * 0.12);
        // data-delay в мс → переводим в секунды и добавляем baseDelay
        const wordDelayMs = parseFloat(el.dataset.delay || 0) + (ANIM.iLoveYou?.baseDelay || 0);
        const startTime = startElapsed + wordDelayMs / 1000;

        wordBursts.push({
          idx,
          start: startTime,
          end: startTime + DUST_DUR,
          revealed: false
        });

        for (let i = 0; i < DUST_PER_WORD; i++) {
          const tx = rect.left + padX + Math.random() * Math.max(2, rect.width - padX * 2);
          const ty = rect.top + padY + Math.random() * Math.max(2, rect.height - padY * 2);
          const sx = tx + (Math.random() - 0.5) * (80 + rect.width * 0.6);
          const sy = ty + 28 + Math.random() * 42;
          dustParticles.push({
            sx,
            sy,
            tx,
            ty,
            start: startTime + Math.random() * 0.22,
            life: DUST_DUR * (0.78 + Math.random() * 0.34),
            seed: Math.random() * Math.PI * 2,
            size: 0.8 + Math.random() * 1.8
          });
        }
      });

      const maxWordDelayMs = Math.max(...Array.from(wordEls).map(el => parseFloat(el.dataset.delay || 0)));
      const deterministicWordsEnd =
        startElapsed +
        maxWordDelayMs / 1000 +
        DUST_START_JITTER_MAX +
        DUST_DUR * DUST_LIFE_MAX_FACTOR;
      lineStartAt = deterministicWordsEnd + LINE_AFTER_LAST_WORD_SEC;
      contourNeonStartAt = lineStartAt + LINE_IN_DUR_SEC + NEON_AFTER_LINE_SEC;
    }

    function updateAndDrawWordDust(elapsed) {
      for (let i = 0; i < wordBursts.length; i++) {
        const b = wordBursts[i];
        if (!b.revealed && elapsed >= b.start + DUST_DUR * 0.72) {
          b.revealed = true;
          wordEls[b.idx].classList.add('visible');
        }
      }

      if (!txtEl.classList.contains('line-on') && elapsed >= lineStartAt) {
        txtEl.classList.add('line-on');
      }

      for (let i = 0; i < dustParticles.length; i++) {
        const d = dustParticles[i];
        const t = (elapsed - d.start) / d.life;
        if (t <= 0 || t >= 1) continue;

        const e = ease(t);
        const swirl = (1 - e) * (3.4 + d.size * 0.5);
        const x = d.sx + (d.tx - d.sx) * e + Math.cos(e * 11 + d.seed) * swirl;
        const y = d.sy + (d.ty - d.sy) * e + Math.sin(e * 9 + d.seed) * swirl * 0.75;
        const alpha = Math.pow(1 - t, 0.52) * 0.92;

        ctx.beginPath();
        ctx.arc(x, y, d.size * (0.66 + (1 - e) * 0.72), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,50,130,${alpha})`;
        ctx.fill();
      }
    }

    function drawParticles() {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          if (p.alpha < 0.01 || p.depth !== layer) continue;

          if (p.isContour) continue; // drawn by neon line, not as dots
          const s = DEPTH_POINT_SCALE[layer];
          const a = p.alpha * DEPTH_POINT_ALPHA[layer];
          const g = p.alpha * DEPTH_GLOW_ALPHA[layer];

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * s, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fill();

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * (2.05 * s), 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255,50,130,${g})`;
          ctx.lineWidth = 0.35 + layer * 0.06;
          ctx.stroke();

          if (layer === 2) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (3.25 * s), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255,50,130,${p.alpha * 0.22})`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
          }
        }
      }
    }

    function drawVolumeFog(elapsed) {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < INTERIOR_COUNT; i++) {
          const p = particles[i];
          if (p.depth !== layer || p.alpha < 0.04) continue;
          if ((i + layer) % 2 !== 0) continue;

          const fogPulse = 0.86 + Math.sin(elapsed * 1.4 + p.phase) * 0.14;
          const alpha = p.alpha * (0.025 + layer * 0.013) * fogPulse;
          const radius = p.size * (4.8 + layer * 1.25);

          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,40,120,${alpha})`;
          ctx.fill();
        }
      }
    }

    function clipToHeartShape() {
      if (!heartClipPath) return;
      ctx.clip(heartClipPath);
    }

    function initInteriorNetwork() {
      links.length = 0;
      const linkCounts = new Uint8Array(INTERIOR_COUNT);
      const grid = new Map();
      const cellSize = LINK_DIST;
      const edgeSet = new Set();

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const gx = Math.floor(p.tx / cellSize);
        const gy = Math.floor(p.ty / cellSize);
        const key = `${gx}|${gy}`;
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(i);
      }

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        const gx = Math.floor(a.tx / cellSize);
        const gy = Math.floor(a.ty / cellSize);
        const candidates = [];

        for (let oy = -2; oy <= 2; oy++) {
          for (let ox = -2; ox <= 2; ox++) {
            const bucket = grid.get(`${gx + ox}|${gy + oy}`);
            if (!bucket) continue;
            for (let bi = 0; bi < bucket.length; bi++) {
              const j = bucket[bi];
              if (j === i) continue;

              const b = particles[j];

              const dx = a.tx - b.tx;
              const dy = a.ty - b.ty;
              const d2 = dx * dx + dy * dy;
              if (d2 > LINK_DIST_SQ) continue;
              candidates.push({ j, d2 });
            }
          }
        }

        candidates.sort((m, n) => m.d2 - n.d2);

        for (let ci = 0; ci < candidates.length; ci++) {
          if (linkCounts[i] >= MAX_LINKS_PER_NODE) break;
          const j = candidates[ci].j;
          if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

          const aIdx = i < j ? i : j;
          const bIdx = i < j ? j : i;
          const key = `${aIdx}|${bIdx}`;
          if (edgeSet.has(key)) continue;

          const d = Math.sqrt(candidates[ci].d2);
          const k = 1 - d / LINK_DIST;
          if (k < 0.025) continue;

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[j]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: 0, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // Ensure each interior particle has minimum links.
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        while (linkCounts[i] < MIN_LINKS_PER_NODE) {
          let bestJ = -1;
          let bestD2 = Infinity;
          for (let j = 0; j < INTERIOR_COUNT; j++) {
            if (j === i) continue;
            const b = particles[j];
            if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

            const aIdx = i < j ? i : j;
            const bIdx = i < j ? j : i;
            const key = `${aIdx}|${bIdx}`;
            if (edgeSet.has(key)) continue;

            const dx = a.tx - b.tx;
            const dy = a.ty - b.ty;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
            }
          }

          if (bestJ === -1) break;

          const aIdx = i < bestJ ? i : bestJ;
          const bIdx = i < bestJ ? bestJ : i;
          const key = `${aIdx}|${bIdx}`;
          const d = Math.sqrt(bestD2);
          const k = Math.max(0.2, 1 - d / (LINK_DIST * 1.8));

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[bestJ]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: k, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // ── BFS from center particle ──────────────────────────────────────────
      // Build adjacency list for interior particles
      bfsOrder.length = 0;
      bfsReady = false;
      activeRays.length = 0;
      for (const k in bfsParentOf) delete bfsParentOf[k];
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];

      const adj = Array.from({ length: INTERIOR_COUNT }, () => []);
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        if (l.a < INTERIOR_COUNT && l.b < INTERIOR_COUNT) {
          adj[l.a].push(l.b);
          adj[l.b].push(l.a);
        }
      }

      // Find particle closest to heart center (cx, cy)
      let centerIdx = 0;
      let centerBestD2 = Infinity;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const dx = p.tx - cx;
        const dy = p.ty - cy;
        const d2 = dx * dx + dy * dy;
        if (d2 < centerBestD2) { centerBestD2 = d2; centerIdx = i; }
      }

      // BFS
      const visited = new Uint8Array(INTERIOR_COUNT);
      const bfsQueue = [centerIdx];
      const bfsDepth = new Float32Array(INTERIOR_COUNT);
      visited[centerIdx] = 1;
      bfsParentOf[centerIdx] = -1;
      bfsOrder.push(centerIdx);
      let maxDepth = 0;
      let head = 0;
      while (head < bfsQueue.length) {
        const cur = bfsQueue[head++];
        const neighbors = adj[cur];
        for (let ni = 0; ni < neighbors.length; ni++) {
          const nb = neighbors[ni];
          if (visited[nb]) continue;
          visited[nb] = 1;
          bfsDepth[nb] = bfsDepth[cur] + 1;
          if (bfsDepth[nb] > maxDepth) maxDepth = bfsDepth[nb];
          bfsParentOf[nb] = cur;
          bfsQueue.push(nb);
          bfsOrder.push(nb);
        }
      }
      bfsMaxDepth = Math.max(1, maxDepth);
      // Store BFS depth on each particle for distance-based timing
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        particles[i].bfsDepth = bfsDepth[i];
      }
      // Center particle has no parent — it appears immediately
      bfsParentOf[centerIdx] = -1;
      bfsReady = true;
    }

    function updateInteriorNetwork(dt, elapsed) {
      if (!bfsReady) return;

      // Trigger particle birth when ray arrives
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (p.born) continue;
        if (bfsTriggerTime[i] === undefined) continue;
        if (elapsed >= bfsTriggerTime[i]) {
          p.born = true;
          p.bornTime = elapsed;
        }
      }

      // Update particle physics & alpha (interior particles: gentle float in place, no spring needed)
      const BIRTH_DUR_BFS = 0.30;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (!p.born) continue;

        p.alpha = ease((elapsed - p.bornTime) / BIRTH_DUR_BFS);

        // Gentle float animation around fixed position
        p.x = p.tx + Math.cos(elapsed * p.pulse * 2.2 + p.phase) * 1.8 * p.mirrorSign;
        p.y = p.ty + Math.sin(elapsed * (p.pulse * 2.0) + p.phase) * 1.8;
      }

      // Update link alphas
      const softDist = LINK_DIST * 1.35;
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        const a = particles[l.a];
        const b = particles[l.b];

        if (!a.born || !b.born) {
          l.targetAlpha = 0;
        } else {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          const distFactor = Math.max(0, 1 - d / softDist);
          l.targetAlpha = Math.min(a.alpha, b.alpha) * distFactor;
        }

        const t = Math.min(1, dt * LINK_ALPHA_SMOOTH);
        l.alpha += (l.targetAlpha - l.alpha) * t;
      }
    }

    // Called once per frame (not inside physics accumulator loop)
    function scheduleBfsRays(elapsed) {
      if (!bfsReady) return;
      const waveStart = NETWORK_START;

      for (let oi = 0; oi < bfsOrder.length; oi++) {
        const idx = bfsOrder[oi];
        const p = particles[idx];
        const parentIdx = bfsParentOf[idx];

        if (bfsTriggerTime[idx] !== undefined) continue; // already scheduled

        if (parentIdx === -1) {
          // Center particle: appears at waveStart
          bfsTriggerTime[idx] = waveStart;
        } else {
          if (bfsTriggerTime[parentIdx] === undefined) continue;

          const parentP = particles[parentIdx];
          const dx = p.tx - parentP.tx;
          const dy = p.ty - parentP.ty;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const rayDur = Math.max(0.08, (dist / (LINK_DIST * 1.2)) * (BFS_TOTAL_DUR / bfsMaxDepth));
          const arrivalTime = bfsTriggerTime[parentIdx] + rayDur;
          bfsTriggerTime[idx] = arrivalTime;

          activeRays.push({
            fromIdx: parentIdx,
            toIdx: idx,
            startTime: bfsTriggerTime[parentIdx],
            dur: rayDur,
            done: false
          });
        }
      }
    }

    function drawInteriorNetwork(elapsed) {
      const shimmer = 0.86 + Math.sin(elapsed * 2.2) * 0.14;

      // Batch by layer and pass to minimise draw calls:
      // Instead of 3 stroke() calls per link (= 3*N calls), we do 3 passes total.
      // Each pass strokes ALL visible links in one path per layer — 9 draw calls total.
      for (let layer = 0; layer <= 2; layer++) {
        const outerColor = layer === 0 ? '180,20,60' : layer === 1 ? '220,30,80' : '255,40,110';
        const mainColor  = layer === 0 ? '200,30,70' : layer === 1 ? '235,50,100' : '255,60,130';
        const coreColor  = layer === 0 ? '220,50,85' : layer === 1 ? '245,80,125' : '255,130,165';
        const depthAlpha = DEPTH_LINK_ALPHA[layer];
        const depthWidth = DEPTH_LINK_WIDTH[layer];
        const frontBoost = layer === 2 ? 1.16 : 1;

        // Collect visible links for this layer first
        const visible = [];
        for (let i = 0; i < links.length; i++) {
          const l = links[i];
          if (l.depth !== layer || l.alpha < 0.01) continue;
          visible.push(l);
        }
        if (visible.length === 0) continue;

        // Pass 1 — outer glow (widest)
        ctx.save();
        ctx.lineWidth = (1.95 + 0.16) * depthWidth * frontBoost;
        ctx.beginPath();
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l.alpha * shimmer * depthAlpha;
          const mx = (a.x + b.x) * 0.5;
          const my = (a.y + b.y) * 0.5;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const nx = -dy / len;
          const ny = dx / len;
          const wobble = Math.sin(elapsed * 3.8 + l.phase) * LINK_WOBBLE;
          const flow = 0.68 + Math.sin(elapsed * LINK_FLOW_SPEED + l.phase * 1.7) * 0.32;
          const drift = Math.cos(elapsed * 4.6 + l.phase * 1.3) * LINK_DRIFT;
          const tx2 = dx / len; const ty2 = dy / len;
          const cx2 = mx + nx * wobble + tx2 * drift;
          const cy2 = my + ny * wobble + ty2 * drift;
          // store per-link computed values for reuse in passes 2 & 3
          l._cx2 = cx2; l._cy2 = cy2; l._al = al; l._flow = flow;
          l._pulse = 0.72 + Math.sin(elapsed * 6.3 + l.phase * 2.4) * 0.28;
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
        }
        // Outer pass uses per-link alpha — must stroke individually (alpha varies per link)
        // But we can at least skip shadowBlur which is the heaviest cost
        ctx.restore();

        // Stroke individually but skip redundant state changes
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // Disable shadow for inner passes on mobile — saves ~40% GPU time
        if (!IS_MOBILE) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l._al;
          const pulse = l._pulse;
          const flow = l._flow;
          const cx2 = l._cx2;
          const cy2 = l._cy2;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${outerColor},${al * 0.28 * flow})`;
          ctx.lineWidth = (1.95 + pulse * 0.16) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${mainColor},${al * 0.5 * pulse})`;
          ctx.lineWidth = (1.2 + pulse * 0.14) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${coreColor},${al * 0.64 * flow})`;
          ctx.lineWidth = (0.84 + pulse * 0.1) * depthWidth * frontBoost;
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    function drawActiveRays(elapsed) {
      if (!bfsReady) return;
      ctx.save();
      ctx.lineCap = 'round';

      for (let i = activeRays.length - 1; i >= 0; i--) {
        const ray = activeRays[i];
        if (ray.done) continue;

        const t = (elapsed - ray.startTime) / ray.dur;
        if (t <= 0) continue;
        if (t >= 1.15) { ray.done = true; continue; }

        const progress = Math.min(1, t);
        const fromP = particles[ray.fromIdx];
        const toP = particles[ray.toIdx];

        // Interpolate ray tip position
        const tipX = fromP.x + (toP.x - fromP.x) * progress;
        const tipY = fromP.y + (toP.y - fromP.y) * progress;

        // Tail fades — ray is short, bright at tip, fading behind
        const tailLen = 0.35; // fraction of total distance shown as tail
        const tailT = Math.max(0, progress - tailLen);
        const tailX = fromP.x + (toP.x - fromP.x) * tailT;
        const tailY = fromP.y + (toP.y - fromP.y) * tailT;

        // Fade out as the ray completes (t > 1)
        const fadeOut = t > 1 ? 1 - (t - 1) / 0.15 : 1;
        const intensity = fadeOut * Math.min(1, progress * 3);

        // Outer glow
        const grd = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
        grd.addColorStop(0, `rgba(255,80,140,0)`);
        grd.addColorStop(0.6, `rgba(255,120,180,${0.35 * intensity})`);
        grd.addColorStop(1, `rgba(255,255,255,${0.95 * intensity})`);

        ctx.shadowColor = 'rgba(255,80,160,0.9)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = grd;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Bright core
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(fromP.x + (toP.x - fromP.x) * Math.max(0, progress - 0.12), fromP.y + (toP.y - fromP.y) * Math.max(0, progress - 0.12));
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = `rgba(255,240,250,${0.98 * intensity})`;
        ctx.lineWidth = 1.0;
        ctx.stroke();

        // Bright tip dot
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(tipX, tipY, 2.2 * intensity, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${intensity})`;
        ctx.fill();
      }

      ctx.restore();
    }

    function getContourPointCW(progress) {
      const start = INTERIOR_COUNT;
      const n = CONTOUR_COUNT;
      const wrapped = ((progress % n) + n) % n;
      const base = wrapped; // counter-clockwise direction
      const i0 = Math.floor(base) % n;
      const i1 = (i0 + 1) % n;
      const frac = base - Math.floor(base);
      const a = particles[start + i0];
      const b = particles[start + i1];
      return {
        x: a.x + (b.x - a.x) * frac,
        y: a.y + (b.y - a.y) * frac
      };
    }

    function drawContourNeon(elapsed) {
      if (!Number.isFinite(contourNeonStartAt) || elapsed < contourNeonStartAt) return;

      const travel = (elapsed - contourNeonStartAt) * NEON_SPEED;
      const head = contourStartIndex + travel;
      const step = Math.max(0.5, NEON_TAIL_SPACING);
      const maxSteps = Math.max(8, NEON_TAIL_STEPS);
      const pinTailDistance = maxSteps * step;
      const pulse = 0.9 + Math.sin(elapsed * 5.6) * 0.1;

      // Strong neon sweep without a terminal "ball".
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = 'rgba(255,255,255,1.00)';
      ctx.shadowBlur = 22;

      for (let band = 0; band < 4; band++) {
        ctx.beginPath();
        for (let i = 0; i <= maxSteps; i++) {
          let pos = head - i * step;
          if (travel < pinTailDistance && pos < contourStartIndex) {
            pos = contourStartIndex;
          }
          const p = getContourPointCW(pos);
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }

        if (band === 0) {
          ctx.strokeStyle = `rgba(255,50,120,${0.65 * pulse})`;
          ctx.lineWidth = 6.4;
        } else if (band === 1) {
          ctx.strokeStyle = `rgba(200,10,50,${0.85 * pulse})`;
          ctx.lineWidth = 4.1;
        } else if (band === 2) {
          ctx.strokeStyle = `rgba(255,230,245,${1.00 * pulse})`;
          ctx.lineWidth = 2.25;
        } else {
          ctx.strokeStyle = `rgba(255,60,90,${1.00 * pulse})`;
          ctx.lineWidth = 1.2;
        }
        ctx.stroke();
      }
      ctx.restore();
    }


    function drawContourThread(elapsed) {
      const contourStartAt = WAVE_START + CONTOUR_START;
      if (elapsed <= contourStartAt) return;
      const n = BND_FIXED.length; // 900
      if (n < 2) return;

      // Notch = i=0 (t=0, top center dip), Bottom = i=n/2 (t=PI, bottom tip)
      // Each arc covers exactly n/2 points — perfect symmetry
      const topIdx = 0;
      const half = Math.floor(n / 2); // 450

      const dur = CONTOUR_COUNT * CONTOUR_STEP;
      const progress = Math.min(1, Math.max(0, (elapsed - contourStartAt) / dur));
      if (progress <= 0) return;

      const visible = Math.round(progress * half); // same for both arcs

      // Unified breathing — same formula for both animation and completed states
      const glowStrength = Math.max(0.1, Math.min(1, ANIM.contour.glow));
      const breathe = (0.82 + Math.sin(elapsed * 2.4) * 0.18) * glowStrength;

      function drawNeonLine(pts, closed) {
        if (pts.length < 2) return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // On mobile: skip the two heavy outer glow passes (blur 22 & 11) to save GPU
        const passes = IS_MOBILE ? [
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`, w: 2.2 },
          { blur: 1,  color: `rgba(255,80,140,${0.85 * breathe})`, w: 0.9 },
        ] : [
          { blur: 22, color: `rgba(255,40,110,${0.28 * breathe})`,  w: 11  },
          { blur: 11, color: `rgba(255,200,230,${0.45 * breathe})`, w: 5   },
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`, w: 2.2 },
          { blur: 2,  color: `rgba(255,80,140,${0.85 * breathe})`, w: 0.9 },
        ];
        for (const p of passes) {
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          if (closed) ctx.closePath();
          ctx.shadowColor = 'rgba(220,20,70,1)';
          ctx.shadowBlur = p.blur;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.w;
          ctx.stroke();
        }
        ctx.restore();
      }

      if (progress >= 1) {
        // Full closed heart — same unified neon passes
        drawNeonLine(BND_FIXED, true);
        return;
      }

      // CW arc: 0 → 1 → 2 → ... → visible  (right side going down)
      const cwPts = [];
      for (let k = 0; k <= visible; k++) cwPts.push(BND_FIXED[k]);

      // CCW arc: 0 → n-1 → n-2 → ... → n-visible  (left side going down)
      // Skip index 0 (already in cwPts) to avoid double-rendering the notch point
      const ccwPts = [];
      for (let k = 1; k <= visible; k++) ccwPts.push(BND_FIXED[(n - k) % n]);

      // Draw as single merged path: ccw reversed + cw, so it's one continuous stroke from left tip → notch → right tip
      // This prevents the neon glow from stacking double at the starting notch point
      const mergedPts = [...ccwPts.slice().reverse(), ...cwPts];
      drawNeonLine(mergedPts, false);
    }

    let segStart = 0;
    let segEnd = 0;

    let direction = 1; // 1 = сверху вниз, -1 = снизу вверх
    let phase = 0;     // 0 = grow, 1 = shrink

    function drawContourNeon(elapsed) {
      if (!Number.isFinite(contourNeonStartAt) || elapsed < contourNeonStartAt) return;

      const n = BND_FIXED.length;
      const half = Math.floor(n / 2);
      const speed = ANIM.sweep.sweepSpeed;

      // --- ОБНОВЛЕНИЕ СОСТОЯНИЯ ---

      if (phase === 0) {
        // GROW
        segEnd += speed;

        if (segEnd >= half) {
          segEnd = half;
          phase = 1;
        }
      } else {
        // SHRINK
        segStart += speed;

        if (segStart >= half) {
          segStart = 0;
          segEnd = 0;
          phase = 0;
          direction *= -1;
        }
      }

      const start = Math.floor(segStart);
      const end = Math.floor(segEnd);

      if (end <= start) return;

      const dimFactor = IS_MOBILE ? 0.55 : 0.80;
      const sweepPasses = [
        { blur: 10, color: `rgba(255,210,235,${0.10 * dimFactor})`, w: 8   },
        { blur: 4,  color: `rgba(255,235,248,${0.28 * dimFactor})`, w: 3.0 },
        { blur: 1,  color: `rgba(255,255,255,${0.45 * dimFactor})`, w: 1.2 },
        { blur: 0,  color: `rgba(255,255,255,${0.55 * dimFactor})`, w: 0.5 },
      ];

      function draw(indices) {
        if (indices.length < 2) return;

        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (const p of sweepPasses) {
          ctx.beginPath();
          const first = BND_FIXED[indices[0]];
          ctx.moveTo(first.x, first.y);

          for (let i = 1; i < indices.length; i++) {
            const pt = BND_FIXED[indices[i]];
            ctx.lineTo(pt.x, pt.y);
          }

          ctx.shadowColor = 'rgba(255,255,255,0.85)';
          ctx.shadowBlur = p.blur;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.w;
          ctx.stroke();
        }

        ctx.restore();
      }

      const right = [];
      const left = [];

      for (let i = start; i <= end; i++) {
        let idx;

        if (direction === 1) {
          idx = i; // сверху вниз
        } else {
          idx = half - i; // снизу вверх
        }

        right.push(idx);
        left.push((n - idx) % n);
      }

      draw(right);
      draw(left);
    }

    function frame() {
      if (!started) return;
      const now = Date.now();
      const elapsed = (now - start) / 1000;
      const realDt = Math.min(0.1, (now - last) / 1000); // реальное время кадра, но не больше 100мс
      const animElapsed = elapsed * MAIN_TIME_SCALE;
      last = now;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // Accumulator: догоняем пропущенные шаги физики если кадр был тяжёлым
      physicsAccumulator += realDt;
      let steps = 0;
      while (physicsAccumulator >= PHYSICS_STEP && steps < 4) {
        const animDt = PHYSICS_STEP * MAIN_TIME_SCALE;

        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];

          // Interior particles are handled by updateInteriorNetwork (BFS wave)
          if (!p.isContour && i < INTERIOR_COUNT) continue;

          const baseStart = WAVE_START + p.spawnAt;
          const st = p.isContour
            ? baseStart
            : NETWORK_START + p.spawnAt;

          if (animElapsed >= st && !p.born) {
            p.born = true;
            p.bornTime = animElapsed;
          }

          if (!p.born) continue;

          p.alpha = ease((animElapsed - p.bornTime) / BIRTH_DUR);

          let targetX = p.tx;
          let targetY = p.ty;
          if (!p.isContour) {
            targetX += Math.cos(animElapsed * p.pulse * 2.2 + p.phase) * 1.8 * p.mirrorSign;
            targetY += Math.sin(animElapsed * (p.pulse * 2.0) + p.phase) * 1.8;
          }

          const ax = (targetX - p.x) * SPRING;
          const ay = (targetY - p.y) * SPRING;
          p.vx = (p.vx + ax * animDt) * DAMPING;
          p.vy = (p.vy + ay * animDt) * DAMPING;
          p.x += p.vx * animDt;
          p.y += p.vy * animDt;
        }

        updateInteriorNetwork(animDt, animElapsed);
        physicsAccumulator -= PHYSICS_STEP;
        steps++;
      }

      if (!textStarted && animElapsed >= TEXT_START) {
        startText(animElapsed);
      }

      // Schedule BFS rays once per frame (not in physics loop to avoid duplicates)
      scheduleBfsRays(animElapsed);

      ctx.save();
      clipToHeartShape();
      drawVolumeFog(animElapsed);
      drawInteriorNetwork(animElapsed);
      drawActiveRays(animElapsed);
      ctx.restore();
      drawParticles();
      drawContourThread(animElapsed);
      drawContourNeon(animElapsed);
      updateAndDrawWordDust(animElapsed);
      requestAnimationFrame(frame);
    }

    function startExperience() {
      if (started || startPending) return;
      startPending = true;
      bgMusic.currentTime = 0;
      bgMusic.play().catch(() => { });
      introEl.classList.add('exiting');

      window.setTimeout(() => {
        if (started) return;
        introEl.classList.add('hidden');
        preludeEl.classList.remove('show', 'done');
        prelude2El.classList.remove('show', 'done');
        // Сбрасываем все слова
        preludeEl.querySelectorAll('.word').forEach(w => w.classList.remove('visible'));
        prelude2El.querySelectorAll('.word').forEach(w => w.classList.remove('visible'));

        const getDelay = (el) => parseFloat(el.dataset.delay || 0);

        // ── PRELUDE 1 ──────────────────────────────────────────
        const cfg1 = ANIM.preludeFirst;
        const p1part1Els = preludeEl.querySelectorAll('.p1-part1');
        const p1part2Els = preludeEl.querySelectorAll('.p1-part2');
        const p1Start = cfg1.delay * 1000 + (cfg1.wordDelay || 0);
        const p1MaxDelay = Math.max(...Array.from(p1part1Els).map(getDelay));

        // Показываем prelude контейнер
        window.setTimeout(() => preludeEl.classList.add('show'), p1Start);

        // Часть 1: показываем слова по data-delay
        p1part1Els.forEach(w => {
          window.setTimeout(() => w.classList.add('visible'), p1Start + getDelay(w));
        });

        // Часть 1 исчезает быстро и плавно
        const p1HideAt = p1Start + p1MaxDelay + cfg1.part1HideAfter;
        window.setTimeout(() => {
          p1part1Els.forEach(w => {
            if (w.classList.contains('visible')) {
              w.classList.add('fadeout');
            }
          });
        }, p1HideAt);

        // Часть 2 появляется
        const p1Part2At = p1HideAt + cfg1.part2ShowAfter;
        window.setTimeout(() => {
          p1part2Els.forEach(w => w.classList.add('visible'));
        }, p1Part2At);

        // Часть 2 исчезает + весь prelude1 скрывается
        const p1EndAt = p1Part2At + cfg1.part2HideAfter;
        window.setTimeout(() => {
          preludeEl.classList.add('done');
        }, p1EndAt);

        // ── PRELUDE 2 ──────────────────────────────────────────
        const cfg2 = ANIM.preludeSecond;
        const p2part1Els = prelude2El.querySelectorAll('.p2-part1');
        const p2part2Els = prelude2El.querySelectorAll('.p2-part2');
        const p2Start = cfg2.delay * 1000 + (cfg2.wordDelay || 0);
        const p2MaxDelay = Math.max(...Array.from(p2part1Els).map(getDelay));

        window.setTimeout(() => prelude2El.classList.add('show'), p2Start);

        p2part1Els.forEach(w => {
          window.setTimeout(() => w.classList.add('visible'), p2Start + getDelay(w));
        });

        const p2HideAt = p2Start + p2MaxDelay + cfg2.part1HideAfter;
        window.setTimeout(() => {
          p2part1Els.forEach(w => {
            if (w.classList.contains('visible')) {
              w.classList.add('fadeout');
            }
          });
        }, p2HideAt);

        const p2Part2At = p2HideAt + cfg2.part2ShowAfter;
        window.setTimeout(() => {
          p2part2Els.forEach(w => w.classList.add('visible'));
        }, p2Part2At);

        const p2EndAt = p2Part2At + cfg2.part2HideAfter;
        window.setTimeout(() => {
          prelude2El.classList.add('done');
        }, p2EndAt);

        // ── MAIN ANIMATION ─────────────────────────────────────
        const mainStartDelay = MAIN_ANIMATION_START_AT_SEC * 1000;
        window.setTimeout(() => {
          started = true;
          preludeEl.classList.remove('show', 'done');
          prelude2El.classList.remove('show', 'done');
          resize();
          frame();
        }, mainStartDelay);
      }, 560);
    }

    window.addEventListener('resize', resize);
    startBtn.addEventListener('click', startExperience);
  </script>
</body>

</html>