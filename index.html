<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Raleway:wght@200;300;600;700&family=Great+Vibes&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Raleway:wght@200;300;600;700&family=Great+Vibes&display=swap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I Love You</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    #intro {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 50% 40%, rgba(80, 5, 30, 0.60), rgba(0, 0, 0, 1) 58%);
      transition: opacity 480ms ease;
    }

    #intro.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #intro.exiting {
      pointer-events: none;
    }

    #startBtn {
      border: 0;
      background: transparent;
      color: #ff4488;
      font-family: 'Georgia', serif;
      font-size: clamp(22px, 3.8vw, 34px);
      letter-spacing: 0.08em;
      line-height: 1.2;
      cursor: pointer;
      text-align: center;
      text-shadow:
        0 0 14px rgba(255,30,120, 0.90),
        0 0 30px rgba(220,20,80, 0.70),
        0 0 55px rgba(180,10,60, 0.45);
      animation: introPulse 1900ms ease-in-out infinite;
    }

    #intro.exiting #startBtn {
      animation: introExit 540ms cubic-bezier(.2, .9, .2, 1) forwards;
    }

    #intro.exiting {
      animation: introFade 420ms ease forwards 180ms;
    }

    #startBtn .heart {
      display: block;
      font-size: clamp(42px, 8vw, 68px);
      margin-bottom: 10px;
    }

    #startBtn .label {
      display: block;
      font-size: clamp(18px, 2.8vw, 28px);
    }

    @keyframes introPulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 0.9;
      }

      50% {
        transform: scale(1.04);
        opacity: 1;
      }
    }

    @keyframes introExit {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      34% {
        transform: scale(1.11);
        opacity: 1;
      }

      100% {
        transform: scale(0.78);
        opacity: 0;
      }
    }

    @keyframes introFade {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* ── I LOVE YOU — handwriting SVG ──────────────────────────────── */
    #txt {
      position: fixed;
      bottom: 60px;
      width: 100%;
      text-align: center;
      pointer-events: none;
      white-space: nowrap;
      /* hidden — replaced by SVG canvas below */
      opacity: 0;
      font-size: 0;
    }

    #iloveyou-svg {
      position: fixed;
      bottom: 40px;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none;
      overflow: visible;
      display: block;
    }

    /* Each word group */
    .ily-word {
      opacity: 0;
    }

    /* The neon stroke that draws itself */
    .ily-stroke {
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .ily-fill { display: none; }

    @keyframes ilyDraw {
      from { stroke-dashoffset: var(--dash-len); }
      to   { stroke-dashoffset: 0; }
    }
    @keyframes ilyGlow {
      from { opacity: 0; }
      to   { opacity: 1; }
    }
    @keyframes ilyWordIn {
      from { opacity: 0; }
      to   { opacity: 1; }
    }

    #txt::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%) scaleX(0.25);
      transform-origin: center;
      bottom: -8px;
      width: min(380px, 72vw);
      height: 2px;
      background: linear-gradient(90deg, rgba(220,20,80,0), rgba(255,60,130,1.00), rgba(220,20,80,0));
      filter: drop-shadow(0 0 8px rgba(255,40,120,0.90));
      opacity: 0;
    }
    #txt.line-on::after {
      animation: lineIn 850ms cubic-bezier(.2,.9,.2,1) forwards, linePulse 2600ms ease-in-out infinite 850ms;
    }
    @keyframes lineIn {
      from { opacity:0; transform:translateX(-50%) scaleX(0.25); filter:drop-shadow(0 0 2px rgba(180,40,90,.30)); }
      to   { opacity:.9; transform:translateX(-50%) scaleX(1);   filter:drop-shadow(0 0 10px rgba(235,90,140,.85)); }
    }
    @keyframes linePulse {
      0%,100% { opacity:.88; filter:drop-shadow(0 0 10px rgba(210,60,110,.82)); }
      50%     { opacity:1;   filter:drop-shadow(0 0 14px rgba(235,90,140,.92)); }
    }
    @media (max-width: 520px) { #txt { letter-spacing: 0.15em; } }

    /* ── PRELUDE: canvas overlay ────────────────────────────────────── */
    #prelude-canvas {
      position: fixed;
      inset: 0;
      z-index: 15;
      pointer-events: none;
    }

    /* Hidden text elements used only to measure word geometry */
    #prelude, #prelude2 {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      opacity: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #prelude-part1, #prelude-part2,
    #prelude2-part1, #prelude2-part2 {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      text-align: center;
    }
    #prelude .word, #prelude2 .word {
      display: inline-block;
      margin: 0 0.18em;
      font-family: 'Georgia', serif;
      font-size: clamp(26px, 5.2vw, 56px);
      font-style: italic;
      white-space: nowrap;
    }
    #prelude .word.accent, #prelude2 .word.accent {
      font-size: clamp(32px, 6.5vw, 72px);
    }

  </style>
</head>

<body>
  <div id="intro">
    <button id="startBtn" type="button" aria-label="Start animation">
      <span class="heart">❤️</span>
      <span class="label">Click me</span>
    </button>
  </div>

  <!-- Measurement-only prelude elements (opacity:0, z-index:-1) -->
  <!-- data-delay (мс) — задержка появления каждого слова от startAt прелюдии -->
  <div id="prelude" aria-hidden="true">
    <div id="prelude-part1">
      <span class="word p1-part1" data-delay="0">This</span>
      <span class="word p1-part1" data-delay="480">is</span>
      <span class="word p1-part1" data-delay="960">all</span>
      <span class="word p1-part1" data-delay="1420">for</span>
    </div>
    <div id="prelude-part2">
      <span class="word accent p1-part2" data-delay="0">You</span>
    </div>
  </div>
  <div id="prelude2" aria-hidden="true">
    <div id="prelude2-part1">
      <span class="word p2-part1" data-delay="0">You</span>
      <span class="word p2-part1" data-delay="380">are</span>
      <span class="word p2-part1" data-delay="760">the</span>
      <span class="word p2-part1" data-delay="1140">best</span>
      <span class="word p2-part1" data-delay="1520">thing</span>
    </div>
    <div id="prelude2-part2">
      <span class="word accent p2-part2" data-delay="0">Ever</span>
    </div>
  </div>

  <canvas id="c"></canvas>
  <!-- Particle-prelude overlay canvas -->
  <canvas id="prelude-canvas"></canvas>

  <div id="txt" aria-label="I Love You">
    <span class="word highlight" data-delay="0">I</span>
    <span class="word highlight" data-delay="1450">Love</span>
    <span class="word highlight" data-delay="2800">You</span>
  </div>
  <!-- Handwriting SVG for I Love You — populated by JS -->
  <svg id="iloveyou-svg" aria-hidden="true"></svg>

  <script>
    // ╔══════════════════════════════════════════════════════════════════╗
    // ║                     🎛  НАСТРОЙКИ                               ║
    // ║  Все параметры анимации в одном месте. Меняй и обновляй.        ║
    // ╚══════════════════════════════════════════════════════════════════╝

    const CONFIG = {

      // ── 🎬 ПРЕЛЮДИЯ 1: "This is all for" + "You" ───────────────────
      prelude1: {
        startAt:        8.78,   // секунд от старта до появления первого слова
        holdPart1:      400,   // мс удержания после последнего слова части 1
        overlapPart2:   200,   // мс — насколько раньше появляется "You" (перекрытие)
        holdPart2:      1200,  // мс удержания слова "You"
        fadeIn:         0.40,  // секунд — скорость появления каждого слова
        fadeOut:        0.40,  // секунд — скорость исчезновения
      },

      // ── 🎬 ПРЕЛЮДИЯ 2: "You are the best thing" + "Ever" ───────────
      prelude2: {
        startAt:        17.35, // секунд от старта
        holdPart1:      400,   // мс удержания части 1
        overlapPart2:   200,   // мс перекрытия с "You"
        holdPart2:      1200,  // мс удержания "You"
        fadeIn:         0.40,
        fadeOut:        0.40,
      },

      // ── 💎 PARTICLE NETWORK ─────────────────────────────────────────
      network: {
        startAt:        8.9,   // секунд — когда начинается BFS-волна
        bfsSpeed:       0.25,   // скорость волны (1.0 = нормально, 2.0 = вдвое быстрее)
        linkDist:       68,    // макс. расстояние между точками для создания связи (px)
        particleCount:  700,   // кол-во точек внутри (мобайл: 340)
        contourCount:   260,   // кол-во точек по контуру (мобайл: 180)
        nearMin:        0.74,  // мин. радиус размещения точек (доля от края)
        nearMax:        0.96,  // макс. радиус (0.96 = не касается контура)
      },

      // ── 💓 ПУЛЬСИРУЮЩЕЕ СЕРДЦЕ ──────────────────────────────────────
      pulse: {
        startAt:        19,
        interval:       1.35,  // секунд между ударами
        beatDur:        0.18,  // секунд — длительность одного удара
        waveSpeed:      320,   // px/сек — скорость волны от верхушки вниз
        waveDur:        0.45,  // секунд — как долго светится вспышка на точке/линии
        heartScale:     0.20,  // размер сердечка (доля от sc — масштаба формулы)
      },

      // ── 💬 "I LOVE YOU" ─────────────────────────────────────────────
      iLoveYou: {
        startAt:        14,    // секунд — когда начинает появляться "I"
        delayLove:      1.60,  // секунд после startAt — задержка "Love"
        delayYou:       3.5,   // секунд после startAt — задержка "You"
        drawSpeed:      1,     // скорость рисования (меньше = быстрее)
        glowSpeed:      0.2,   // скорость появления свечения (меньше = быстрее)
        glowDur:        0.9,   // секунд — нарастание неонового свечения
      },

      // ── 💫 "ALINA" ──────────────────────────────────────────────────
      alina: {
        startAt:        19,    // секунд — когда начинает рисоваться имя
        drawSpeed:      2.2,   // секунд на рисование (меньше = быстрее)
        glowSpeed:      0.2,   // скорость появления свечения (меньше = быстрее, 0.8 = с 80% рисования)
      },

      // ── ⏱ КОНТУР СЕРДЦА ─────────────────────────────────────────────
      contour: {
        startAt:        0.45,  // секунд — задержка перед рисованием контура
        speed:          0.27,  // скорость рисования контура
        glow:           5,     // яркость свечения контура после завершения
      },

      // ── 🌐 ОБЩЕЕ ────────────────────────────────────────────────────
      global: {
        mainSpeed:      0.74,  // общая скорость анимации (timeScale)
        mainStartAt:    22.15, // секунд — когда запускается основная анимация
        musicVolume:    0.62,  // громкость музыки (0.0 – 1.0)
      },

    };
    // ╔══════════════════════════════════════════════════════════════════╗
    // ║              конец настроек — дальше не трогать                 ║
    // ╚══════════════════════════════════════════════════════════════════╝

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const pCanvas = document.getElementById('prelude-canvas');
    const pCtx = pCanvas.getContext('2d');

    // Resize prelude canvas to match window
    function resizePreludeCanvas() {
      pCanvas.width = window.innerWidth * (window.devicePixelRatio || 1);
      pCanvas.height = window.innerHeight * (window.devicePixelRatio || 1);
      pCanvas.style.width = window.innerWidth + 'px';
      pCanvas.style.height = window.innerHeight + 'px';
      pCtx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
    }
    resizePreludeCanvas();
    window.addEventListener('resize', resizePreludeCanvas);

    // Mobile optimisation: cap pixel ratio for main canvas (performance), but use full DPR for text
    const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const DPR = IS_MOBILE ? Math.min(window.devicePixelRatio || 1, 2) : (window.devicePixelRatio || 1);
    const TEXT_DPR = window.devicePixelRatio || 1; // full DPR for sharp text on retina

    let W = 0;
    let H = 0;
    let cx = 0;
    let cy = 0;
    let sc = 0;

    // Minimal controls: only delay + speed for each animation block.
    // Wire CONFIG into ANIM (used throughout the engine)
    const ANIM = {
      contour: {
        delay: CONFIG.contour.startAt,
        speed: CONFIG.contour.speed,
        glow:  CONFIG.contour.glow,
      },
      network: {
        delay:    CONFIG.network.startAt,
        speed:    5,
        bfsSpeed: CONFIG.network.bfsSpeed,
      },
      words: {
        delay: CONFIG.iLoveYou.startAt,
        speed: 1,
      },
      line:  { delay: 0.5, speed: 0.05 },
      sweep: { delay: -7, speed: 40, sweepSpeed: 7 },
      preludeFirst: {
        delay:         CONFIG.prelude1.startAt,
        speed:         1,
        wordDelay:     0,
        part1HideAfter: CONFIG.prelude1.holdPart1,
        part2ShowAfter: CONFIG.prelude1.overlapPart2,
        part2HideAfter: CONFIG.prelude1.holdPart2,
      },
      preludeSecond: {
        delay:         CONFIG.prelude2.startAt,
        speed:         1,
        wordDelay:     0,
        part1HideAfter: CONFIG.prelude2.holdPart1,
        part2ShowAfter: CONFIG.prelude2.overlapPart2,
        part2HideAfter: CONFIG.prelude2.holdPart2,
      },
      iLoveYou: { baseDelay: 0 },
      main: {
        delay: CONFIG.global.mainStartAt,
        speed: CONFIG.global.mainSpeed,
      },
    };
    window.ANIM = ANIM;

    const INTERIOR_COUNT = IS_MOBILE ? 340 : CONFIG.network.particleCount;
    const CONTOUR_COUNT = IS_MOBILE ? 180 : CONFIG.network.contourCount;
    const BIRTH_DUR = 0.25 / Math.max(0.1, ANIM.contour.speed);
    const SPRING = 10.5;
    const DAMPING = 0.86;
    const CONTOUR_START = ANIM.contour.delay;
    const CONTOUR_STEP = 0.012 / Math.max(0.1, ANIM.contour.speed);
    const INTERIOR_START = 1.35;
    const CONTOUR_LINE_ALPHA = 0.62;

    const particles = [];
    const boundary = [];
    let heartClipPath = null;
    const links = [];
    const LINK_DIST = CONFIG.network.linkDist;
    const LINK_DIST_SQ = LINK_DIST * LINK_DIST;
    const MIN_LINKS_PER_NODE = 2;
    const MAX_LINKS_PER_NODE = 6;
    const LINK_ALPHA_SMOOTH = 9;
    const LINK_WOBBLE = 4.5;
    const LINK_FLOW_SPEED = 9.0;
    const LINK_DRIFT = 2.4;
    const DEPTH_POINT_SCALE = [0.72, 1.0, 1.42];
    const DEPTH_POINT_ALPHA = [0.45, 0.95, 1.32];
    const DEPTH_GLOW_ALPHA = [0.05, 0.15, 0.34];
    const DEPTH_LINK_ALPHA = [0.46, 1.02, 1.48];
    const DEPTH_LINK_WIDTH = [0.72, 1.08, 1.5];
    let contourStartIndex = 0;
    const BND_FIXED = [];
    let BND_TOP_IDX = 0;

    // ── PULSE HEART ──────────────────────────────────────────────────
    const PULSE_INTERVAL = CONFIG.pulse.interval;
    const PULSE_BEAT_DUR = CONFIG.pulse.beatDur;
    let   pulseBeats     = [];   // { time: animElapsed when beat fired }
    let   lastBeatTime   = -999;
    let   pulseActive    = false;

    function pickDepthLayer() {
      const r = Math.random();
      if (r < 0.34) return 0; // far
      if (r < 0.77) return 1; // mid
      return 2; // front
    }

    function hx(t) {
      return 16 * Math.pow(Math.sin(t), 3);
    }

    function hy(t) {
      return -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
    }

    function resize() {
      const cssW = window.innerWidth;
      const cssH = window.innerHeight;
      W = canvas.width = Math.round(cssW * DPR);
      H = canvas.height = Math.round(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      cx = cssW / 2;
      cy = cssH / 2 - 70;
      // Heart formula spans ±16 units wide and ~18 units tall.
      // Cap sc so the heart fits within the screen with some padding.
      const scByW = (cssW * 0.46) / 16;
      const scByH = (cssH * 0.44) / 18;
      sc = Math.min(scByW, scByH);
      buildHeart();
      resetAnimation();
    }

    function buildHeart() {
      boundary.length = 0;
      const HEART_SEGMENTS = 900;
      for (let i = 0; i < HEART_SEGMENTS; i++) {
        const t = (i / HEART_SEGMENTS) * Math.PI * 2;
        boundary.push({ x: cx + hx(t) * sc, y: cy + hy(t) * sc });
      }

      // Fixed boundary for stable contour drawing (not affected by particle movement)
      BND_FIXED.length = 0;
      for (let i = 0; i < boundary.length; i++) BND_FIXED.push({ x: boundary[i].x, y: boundary[i].y });
      // BND_TOP_IDX is set after contourStartIndex is computed below
      heartClipPath = new Path2D();
      heartClipPath.moveTo(boundary[0].x, boundary[0].y);
      for (let i = 1; i < boundary.length; i++) {
        heartClipPath.lineTo(boundary[i].x, boundary[i].y);
      }
      heartClipPath.closePath();

      particles.length = 0;

      // ── Deterministic seeded RNG (mulberry32) ──────────────────────
      // Same seed every run → fixed particle positions across reloads.
      let _seed = 0xDEADBEEF;
      function srng() {
        _seed |= 0; _seed = _seed + 0x6D2B79F5 | 0;
        let z = Math.imul(_seed ^ (_seed >>> 15), 1 | _seed);
        z = z + Math.imul(z ^ (z >>> 7), 61 | z) ^ z;
        return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
      }

      // ── Place particles near the contour (ring zone) ───────────────
      // Each particle is placed at a random angle on the heart curve,
      // then pulled inward by a small random offset so it never touches
      // the contour but stays close to it.
      const NEAR_MIN = CONFIG.network.nearMin;
      const NEAR_MAX = CONFIG.network.nearMax;

      const pairCount = Math.floor(INTERIOR_COUNT / 2);
      for (let i = 0; i < pairCount; i++) {
        const t       = srng() * Math.PI * 2;
        const r       = NEAR_MIN + srng() * (NEAR_MAX - NEAR_MIN);
        const sx      = hx(t) * sc * r;
        const txR     = cx + Math.abs(sx);
        const txL     = cx - Math.abs(sx);
        const ty      = cy + hy(t) * sc * r;
        const spawnAt = srng() * WAVE_DUR;
        const size    = 1.05 + srng() * 1.35;
        const phase   = srng() * Math.PI * 2;
        const pulse   = 0.5 + srng() * 0.9;
        // Depth: points near contour are mostly front-layer
        const dRoll   = srng();
        const depth   = dRoll < 0.18 ? 0 : dRoll < 0.52 ? 1 : 2;

        particles.push({
          x: txR, y: ty, tx: txR, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false, size, phase, pulse, mirrorSign: 1, depth
        });

        particles.push({
          x: txL, y: ty, tx: txL, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false, size, phase, pulse, mirrorSign: -1, depth
        });
      }

      if (INTERIOR_COUNT % 2 === 1) {
        const t       = srng() * Math.PI * 2;
        const r       = NEAR_MIN + srng() * (NEAR_MAX - NEAR_MIN);
        const tx      = cx;
        const ty      = cy + hy(t) * sc * r;
        const spawnAt = srng() * WAVE_DUR;
        particles.push({
          x: tx, y: ty, tx, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false,
          size: 1.1 + srng() * 1.15,
          phase: srng() * Math.PI * 2,
          pulse: 0.55 + srng() * 0.8,
          mirrorSign: 0, depth: 1
        });
      }

      // Build contour points with uniform arc-length spacing.
      const closed = boundary.slice();
      closed.push(boundary[0]);
      const cumulative = new Array(closed.length).fill(0);
      for (let i = 1; i < closed.length; i++) {
        const dx = closed[i].x - closed[i - 1].x;
        const dy = closed[i].y - closed[i - 1].y;
        cumulative[i] = cumulative[i - 1] + Math.hypot(dx, dy);
      }
      const totalLen = cumulative[cumulative.length - 1] || 1;

      let seg = 1;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const targetLen = (i / CONTOUR_COUNT) * totalLen;
        while (seg < cumulative.length - 1 && cumulative[seg] < targetLen) seg++;

        const l0 = cumulative[seg - 1];
        const l1 = cumulative[seg];
        const t = l1 > l0 ? (targetLen - l0) / (l1 - l0) : 0;
        const a = closed[seg - 1];
        const b = closed[seg];
        const tx = a.x + (b.x - a.x) * t;
        const ty = a.y + (b.y - a.y) * t;

        particles.push({
          x: tx,
          y: ty,
          tx,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt: CONTOUR_START + i * CONTOUR_STEP,
          isContour: true,
          size: 1.25 + srng() * 0.95,
          phase: 0,
          pulse: 0,
          mirrorSign: 0,
          depth: 2
        });
      }

      // Find TOP notch of heart = minimum y near cx (the dip between the two lobes)
      // t = PI gives the bottom tip, t = PI/2 and t = 3PI/2 give the lobes
      // The notch between lobes is near t=0 where hx=0 and hy is local min
      // Find by scanning: smallest y value among contour particles near cx
      let bestNotchScore = Infinity;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        // score = y value + penalty for being far from cx (finds top-center notch)
        const score = p.ty + Math.abs(p.tx - cx) * 1.5;
        if (score < bestNotchScore) {
          bestNotchScore = score;
          contourStartIndex = i;
        }
      }

      // Reveal contour symmetrically from the top notch to both sides.
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        const cw = (i - contourStartIndex + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ccw = (contourStartIndex - i + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ring = Math.min(cw, ccw);
        p.spawnAt = CONTOUR_START + ring * CONTOUR_STEP;
      }

      // Sync BND_TOP_IDX with contourStartIndex
      // The contour particle at contourStartIndex has target tx,ty — find closest BND_FIXED point
      {
        const refP = particles[INTERIOR_COUNT + contourStartIndex];
        let bstD = Infinity;
        for (let i = 0; i < BND_FIXED.length; i++) {
          const dx = BND_FIXED[i].x - refP.tx;
          const dy = BND_FIXED[i].y - refP.ty;
          const d = dx * dx + dy * dy;
          if (d < bstD) { bstD = d; BND_TOP_IDX = i; }
        }
      }

      initInteriorNetwork();
    }

    const WAVE_START = 0.3;
    const WAVE_DUR = 7.4 / Math.max(0.1, ANIM.network.speed);
    const NETWORK_START = ANIM.network.delay;
    const NETWORK_REVEAL_START = NETWORK_START + 0.1;
    const NETWORK_REVEAL_DUR = 0.85 / Math.max(0.1, ANIM.network.speed);

    // BFS wave data — populated in initInteriorNetwork after links are built
    const bfsOrder = [];        // particle indices in BFS visit order (interior only)
    const bfsParentOf = {};     // bfsParentOf[particleIdx] = parentParticleIdx
    const bfsTriggerTime = {};  // bfsTriggerTime[particleIdx] = animElapsed when ray arrives
    let bfsMaxDepth = 1;
    let bfsReady = false;
    // Total duration of the BFS wave spreading across the heart
    const BFS_TOTAL_DUR = 4.0 / Math.max(0.1, ANIM.network.bfsSpeed);
    // Active rays being drawn: { fromIdx, toIdx, startTime, dur, done }
    const activeRays = [];
    const TEXT_START = ANIM.words.delay;
    const NEON_SPEED = ANIM.sweep.speed;
    const NEON_TAIL_STEPS = 74;
    const NEON_TAIL_SPACING = 0.9;
    const CONTOUR_THREAD_ALPHA = 0.78;

    function ease(t) {
      return 1 - Math.pow(1 - Math.min(1, Math.max(0, t)), 3);
    }

    const txtEl = document.getElementById('txt');
    const wordEls = txtEl.querySelectorAll('.word');
    const preludeEl = document.getElementById('prelude');
    const preludeWords = preludeEl.querySelectorAll('.word');
    const prelude2El = document.getElementById('prelude2');
    const prelude2Words = prelude2El.querySelectorAll('.word');
    const introEl = document.getElementById('intro');
    const startBtn = document.getElementById('startBtn');
    const bgMusic = new Audio('music/post malone & swae lee - Sunflower (sped up + reverb).mp3');
    const wordBursts = [];
    const dustParticles = [];
    const DUST_PER_WORD = 95;
    const WORD_STAGGER = 0.42 / Math.max(0.1, ANIM.words.speed);
    const DUST_DUR = 1.05 / Math.max(0.1, ANIM.words.speed);
    const DUST_START_JITTER_MAX = 0.22 / Math.max(0.1, ANIM.words.speed);
    const DUST_LIFE_MAX_FACTOR = 1.12;
    const PRELUDE_WORDS_START_AT_SEC = ANIM.preludeFirst.delay;
    const PRELUDE2_WORDS_START_AT_SEC = ANIM.preludeSecond.delay;
    const MAIN_ANIMATION_START_AT_SEC = ANIM.main.delay;
    const LINE_AFTER_LAST_WORD_SEC = ANIM.line.delay;
    const LINE_IN_DUR_SEC = 0.85 / Math.max(0.1, ANIM.line.speed);
    const NEON_AFTER_LINE_SEC = ANIM.sweep.delay;
    const MAIN_TIME_SCALE = Math.max(0.2, ANIM.main.speed);

    let physicsAccumulator = 0;
    const PHYSICS_STEP = 1 / 60;
    let start = 0;
    let last = 0;
    let textStarted = false;
    let started = false;
    let startPending = false;
    let lineStartAt = Infinity;
    let contourNeonStartAt = Infinity;
    bgMusic.loop = false;
    bgMusic.volume = CONFIG.global.musicVolume;

    function resetAnimation() {
      start = Date.now();
      last = start;
      textStarted = false;
      lineStartAt = Infinity;
      contourNeonStartAt = Infinity;
      wordBursts.length = 0;
      dustParticles.length = 0;
      activeRays.length = 0;
      // Clear only runtime trigger times (re-scheduled each run), keep bfsParentOf (static tree)
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];
      txtEl.classList.remove('line-on');
      wordEls.forEach((w) => {
        w.classList.remove('visible', 'burst-in', 'burst-out', 'fog-in');
        w.style.animation = 'none';
        w.offsetHeight;
        w.style.animation = '';
      });
      // Reset SVG handwriting
      if (typeof ilySvg !== 'undefined') {
        ilySvg.innerHTML = '';
        ilyBuilt = false;
      }

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        // All particles stay at their target position — no "blooming from center" animation.
        // They appear in place via alpha fade (contour) or BFS chain reaction (interior).
        p.x = p.tx;
        p.y = p.ty;
        p.vx = 0;
        p.vy = 0;
        p.alpha = 0;
        p.born = false;
        p.bornTime = 0;
      }
    }

    // ── HANDWRITING "I LOVE YOU" ─────────────────────────────────────
    // Uses SVG <text> with stroke-dashoffset animation to simulate
    // a pen drawing each word. After drawing, a neon glow fades in.

    const ilySvg   = document.getElementById('iloveyou-svg');
    // ── I LOVE YOU — Canvas рендер (надёжно на iOS Safari) ──────────
    // SVG stroke-dashoffset ненадёжен в Safari — используем Canvas + lineDash

    const ILY_WORDS = [
      { text: 'I',    delaySec: 0.0  },
      { text: 'Love', delaySec: CONFIG.iLoveYou.delayLove },
      { text: 'You',  delaySec: CONFIG.iLoveYou.delayYou  }
    ];

    const ILY_DRAW_BASE = CONFIG.iLoveYou.drawSpeed;
    const ILY_GLOW_DUR  = CONFIG.iLoveYou.glowDur;

    // Состояние каждого слова
    const ilyWords = ILY_WORDS.map(w => ({
      ...w,
      triggered: false,
      startTime: null,
    }));

    let ilyBuilt    = false;
    let ilyFontSize = 0;
    let ilyY        = 0;   // Y позиция текста на canvas (от верха экрана)
    let ilyLayout   = [];  // [{text, x, pathLen, drawDur}]

    function buildIlySvg() {
      // скрываем SVG — рендерим на canvas
      ilySvg.style.display = 'none';
    }

    function buildIlyLayout() {
      if (ilyBuilt) return;
      ilyBuilt = true;

      const screenW = window.innerWidth;
      const screenH = window.innerHeight;

      ilyFontSize = Math.round(IS_MOBILE
        ? Math.max(32, Math.min(54, screenW * 0.058))
        : Math.max(42, Math.min(88, screenW * 0.078)));

      const off = document.createElement('canvas').getContext('2d');
      off.font = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
      const GAP = off.measureText(' ').width * 1.1;

      let ws = ILY_WORDS.map(w => ({ ...w, width: off.measureText(w.text).width }));
      let totalW = ws.reduce((s, w) => s + w.width, 0) + GAP * (ws.length - 1);

      // масштабируем если не влезает
      if (totalW > screenW * 0.92) {
        const scale = (screenW * 0.92) / totalW;
        ilyFontSize = Math.round(ilyFontSize * scale);
        off.font = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
        ws = ILY_WORDS.map(w => ({ ...w, width: off.measureText(w.text).width }));
        totalW = ws.reduce((s, w) => s + w.width, 0) + GAP * (ws.length - 1);
      }

      // Y — снизу экрана как в оригинале
      ilyY = screenH - ilyFontSize * 1.1;

      let curX = (screenW - totalW) / 2;
      ilyLayout = ws.map(w => {
        // Great Vibes — рукописный шрифт с завитками, реальный путь глифа
        // намного длиннее чем measureText. Используем щедрый множитель.
        // Для "I" особенно — у него завиток сверху и снизу.
        const charMultiplier = w.text === 'I' ? 10.0 : w.text === 'You' ? 9.0 : 6.0;
        const pathLen = Math.max(w.width * charMultiplier, ilyFontSize * w.text.length * 4.0);
        const drawDur = ILY_DRAW_BASE * (0.5 + w.text.length * 0.28);
        const x = curX + w.width / 2;
        curX += w.width + GAP;
        return { text: w.text, x, pathLen, drawDur };
      });
    }

    function drawIlyCanvas(elapsed) {
      if (!textStarted) return;
      buildIlyLayout();

      ctx.save();
      ctx.font         = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'alphabetic';

      ILY_WORDS.forEach((word, wi) => {
        const triggerAt = TEXT_START + word.delaySec;
        if (elapsed < triggerAt) return;

        const st = ilyWords[wi];
        if (!st.startTime) st.startTime = elapsed;

        const t      = elapsed - st.startTime;
        const layout = ilyLayout[wi];
        if (!layout) return;

        const { x, pathLen, drawDur } = layout;

        // drawT: [0→1] прогресс рисования штриха
        const drawT  = Math.min(1, t / drawDur);
        // glowT: начинает нарастать с glowSpeed% рисования — плавно перетекает
        const glowStart = 1 - CONFIG.iLoveYou.glowSpeed;
        const glowT  = Math.min(1, Math.max(0, (drawT - glowStart) / (1 - glowStart)));
        // fadeIn: плавное появление в самом начале
        const fadeIn = Math.min(1, t / 0.25);
        const offset = pathLen * (1 - drawT);

        // Слой 0 — лёгкий широкий ореол
        ctx.globalAlpha = fadeIn * glowT * 0.12;
        ctx.lineWidth   = 8;
        ctx.strokeStyle = 'rgba(255,80,150,1)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);

        // Слой 1 — средний розовый
        ctx.globalAlpha = fadeIn * glowT * 0.22;
        ctx.lineWidth   = 3.5;
        ctx.strokeStyle = 'rgba(255,120,180,1)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);

        // Слой 2 — белое ядро
        ctx.globalAlpha = fadeIn * (0.75 + glowT * 0.25);
        ctx.lineWidth   = 1.2;
        ctx.strokeStyle = 'rgba(255,245,252,0.95)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);
      });

      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.shadowBlur  = 0;
      ctx.restore();
    }

    function startText(elapsed) {
      textStarted = true;
      const build = () => buildIlyLayout();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(build);
      } else {
        build();
      }

      const lastWord    = ILY_WORDS[ILY_WORDS.length - 1];
      const lastDrawDur = ILY_DRAW_BASE * (0.7 + lastWord.text.length * 0.18);
      lineStartAt        = elapsed + lastWord.delaySec + lastDrawDur + ILY_GLOW_DUR + 0.3;
      contourNeonStartAt = lineStartAt + LINE_IN_DUR_SEC + NEON_AFTER_LINE_SEC;
    }

    function updateAndDrawWordDust(elapsed) {
      drawIlyCanvas(elapsed);

      if (!txtEl.classList.contains('line-on') && elapsed >= lineStartAt) {
        txtEl.classList.add('line-on');
      }
    }

    function drawParticles() {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          if (p.alpha < 0.01 || p.depth !== layer) continue;

          if (p.isContour) continue; // drawn by neon line, not as dots
          const s = DEPTH_POINT_SCALE[layer];
          const a = p.alpha * DEPTH_POINT_ALPHA[layer];
          const g = p.alpha * DEPTH_GLOW_ALPHA[layer];

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * s, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fill();

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * (2.05 * s), 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255,50,130,${g})`;
          ctx.lineWidth = 0.35 + layer * 0.06;
          ctx.stroke();

          if (layer === 2) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (3.25 * s), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255,50,130,${p.alpha * 0.22})`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
          }
        }
      }
    }

    function drawVolumeFog(elapsed) {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < INTERIOR_COUNT; i++) {
          const p = particles[i];
          if (p.depth !== layer || p.alpha < 0.04) continue;
          if ((i + layer) % 2 !== 0) continue;

          const fogPulse = 0.86 + Math.sin(elapsed * 1.4 + p.phase) * 0.14;
          const alpha = p.alpha * (0.025 + layer * 0.013) * fogPulse;
          const radius = p.size * (4.8 + layer * 1.25);

          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,40,120,${alpha})`;
          ctx.fill();
        }
      }
    }

    function clipToHeartShape() {
      if (!heartClipPath) return;
      ctx.clip(heartClipPath);
    }

    function initInteriorNetwork() {
      links.length = 0;
      const linkCounts = new Uint8Array(INTERIOR_COUNT);
      const grid = new Map();
      const cellSize = LINK_DIST;
      const edgeSet = new Set();

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const gx = Math.floor(p.tx / cellSize);
        const gy = Math.floor(p.ty / cellSize);
        const key = `${gx}|${gy}`;
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(i);
      }

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        const gx = Math.floor(a.tx / cellSize);
        const gy = Math.floor(a.ty / cellSize);
        const candidates = [];

        for (let oy = -2; oy <= 2; oy++) {
          for (let ox = -2; ox <= 2; ox++) {
            const bucket = grid.get(`${gx + ox}|${gy + oy}`);
            if (!bucket) continue;
            for (let bi = 0; bi < bucket.length; bi++) {
              const j = bucket[bi];
              if (j === i) continue;

              const b = particles[j];

              const dx = a.tx - b.tx;
              const dy = a.ty - b.ty;
              const d2 = dx * dx + dy * dy;
              if (d2 > LINK_DIST_SQ) continue;
              candidates.push({ j, d2 });
            }
          }
        }

        candidates.sort((m, n) => m.d2 - n.d2);

        for (let ci = 0; ci < candidates.length; ci++) {
          if (linkCounts[i] >= MAX_LINKS_PER_NODE) break;
          const j = candidates[ci].j;
          if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

          const aIdx = i < j ? i : j;
          const bIdx = i < j ? j : i;
          const key = `${aIdx}|${bIdx}`;
          if (edgeSet.has(key)) continue;

          const d = Math.sqrt(candidates[ci].d2);
          const k = 1 - d / LINK_DIST;
          if (k < 0.025) continue;

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[j]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: 0, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // Ensure each interior particle has minimum links.
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        while (linkCounts[i] < MIN_LINKS_PER_NODE) {
          let bestJ = -1;
          let bestD2 = Infinity;
          for (let j = 0; j < INTERIOR_COUNT; j++) {
            if (j === i) continue;
            const b = particles[j];
            if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

            const aIdx = i < j ? i : j;
            const bIdx = i < j ? j : i;
            const key = `${aIdx}|${bIdx}`;
            if (edgeSet.has(key)) continue;

            const dx = a.tx - b.tx;
            const dy = a.ty - b.ty;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
            }
          }

          if (bestJ === -1) break;

          const aIdx = i < bestJ ? i : bestJ;
          const bIdx = i < bestJ ? bestJ : i;
          const key = `${aIdx}|${bIdx}`;
          const d = Math.sqrt(bestD2);
          const k = Math.max(0.2, 1 - d / (LINK_DIST * 1.8));

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[bestJ]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: k, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // ── BFS from center particle ──────────────────────────────────────────
      // Build adjacency list for interior particles
      bfsOrder.length = 0;
      bfsReady = false;
      activeRays.length = 0;
      for (const k in bfsParentOf) delete bfsParentOf[k];
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];

      const adj = Array.from({ length: INTERIOR_COUNT }, () => []);
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        if (l.a < INTERIOR_COUNT && l.b < INTERIOR_COUNT) {
          adj[l.a].push(l.b);
          adj[l.b].push(l.a);
        }
      }

      // Find particle closest to heart center (cx, cy)
      let centerIdx = 0;
      let centerBestD2 = Infinity;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const dx = p.tx - cx;
        const dy = p.ty - cy;
        const d2 = dx * dx + dy * dy;
        if (d2 < centerBestD2) { centerBestD2 = d2; centerIdx = i; }
      }

      // BFS
      const visited = new Uint8Array(INTERIOR_COUNT);
      const bfsQueue = [centerIdx];
      const bfsDepth = new Float32Array(INTERIOR_COUNT);
      visited[centerIdx] = 1;
      bfsParentOf[centerIdx] = -1;
      bfsOrder.push(centerIdx);
      let maxDepth = 0;
      let head = 0;
      while (head < bfsQueue.length) {
        const cur = bfsQueue[head++];
        const neighbors = adj[cur];
        for (let ni = 0; ni < neighbors.length; ni++) {
          const nb = neighbors[ni];
          if (visited[nb]) continue;
          visited[nb] = 1;
          bfsDepth[nb] = bfsDepth[cur] + 1;
          if (bfsDepth[nb] > maxDepth) maxDepth = bfsDepth[nb];
          bfsParentOf[nb] = cur;
          bfsQueue.push(nb);
          bfsOrder.push(nb);
        }
      }
      bfsMaxDepth = Math.max(1, maxDepth);
      // Store BFS depth on each particle for distance-based timing
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        particles[i].bfsDepth = bfsDepth[i];
      }
      // Center particle has no parent — it appears immediately
      bfsParentOf[centerIdx] = -1;
      bfsReady = true;
    }

    function updateInteriorNetwork(dt, elapsed) {
      if (!bfsReady) return;

      // Trigger particle birth when ray arrives
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (p.born) continue;
        if (bfsTriggerTime[i] === undefined) continue;
        if (elapsed >= bfsTriggerTime[i]) {
          p.born = true;
          p.bornTime = elapsed;
        }
      }

      // Update particle physics & alpha (interior particles: gentle float in place, no spring needed)
      const BIRTH_DUR_BFS = 0.30;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (!p.born) continue;

        p.alpha = ease((elapsed - p.bornTime) / BIRTH_DUR_BFS);

        // Gentle float animation around fixed position
        p.x = p.tx + Math.cos(elapsed * p.pulse * 2.2 + p.phase) * 1.8 * p.mirrorSign;
        p.y = p.ty + Math.sin(elapsed * (p.pulse * 2.0) + p.phase) * 1.8;
      }

      // Update link alphas
      const softDist = LINK_DIST * 1.35;
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        const a = particles[l.a];
        const b = particles[l.b];

        if (!a.born || !b.born) {
          l.targetAlpha = 0;
        } else {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          const distFactor = Math.max(0, 1 - d / softDist);
          l.targetAlpha = Math.min(a.alpha, b.alpha) * distFactor;
        }

        const t = Math.min(1, dt * LINK_ALPHA_SMOOTH);
        l.alpha += (l.targetAlpha - l.alpha) * t;
      }
    }

    // Called once per frame (not inside physics accumulator loop)
    function scheduleBfsRays(elapsed) {
      if (!bfsReady) return;
      const waveStart = NETWORK_START;

      for (let oi = 0; oi < bfsOrder.length; oi++) {
        const idx = bfsOrder[oi];
        const p = particles[idx];
        const parentIdx = bfsParentOf[idx];

        if (bfsTriggerTime[idx] !== undefined) continue; // already scheduled

        if (parentIdx === -1) {
          // Center particle: appears at waveStart
          bfsTriggerTime[idx] = waveStart;
        } else {
          if (bfsTriggerTime[parentIdx] === undefined) continue;

          const parentP = particles[parentIdx];
          const dx = p.tx - parentP.tx;
          const dy = p.ty - parentP.ty;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const rayDur = Math.max(0.08, (dist / (LINK_DIST * 1.2)) * (BFS_TOTAL_DUR / bfsMaxDepth));
          const arrivalTime = bfsTriggerTime[parentIdx] + rayDur;
          bfsTriggerTime[idx] = arrivalTime;

          activeRays.push({
            fromIdx: parentIdx,
            toIdx: idx,
            startTime: bfsTriggerTime[parentIdx],
            dur: rayDur,
            done: false
          });
        }
      }
    }

    function drawInteriorNetwork(elapsed) {
      const shimmer = 0.86 + Math.sin(elapsed * 2.2) * 0.14;

      // Batch by layer and pass to minimise draw calls:
      // Instead of 3 stroke() calls per link (= 3*N calls), we do 3 passes total.
      // Each pass strokes ALL visible links in one path per layer — 9 draw calls total.
      for (let layer = 0; layer <= 2; layer++) {
        const outerColor = layer === 0 ? '180,20,60' : layer === 1 ? '220,30,80' : '255,40,110';
        const mainColor  = layer === 0 ? '200,30,70' : layer === 1 ? '235,50,100' : '255,60,130';
        const coreColor  = layer === 0 ? '220,50,85' : layer === 1 ? '245,80,125' : '255,130,165';
        const depthAlpha = DEPTH_LINK_ALPHA[layer];
        const depthWidth = DEPTH_LINK_WIDTH[layer];
        const frontBoost = layer === 2 ? 1.16 : 1;

        // Collect visible links for this layer first
        const visible = [];
        for (let i = 0; i < links.length; i++) {
          const l = links[i];
          if (l.depth !== layer || l.alpha < 0.01) continue;
          visible.push(l);
        }
        if (visible.length === 0) continue;

        // Pass 1 — outer glow (widest)
        ctx.save();
        ctx.lineWidth = (1.95 + 0.16) * depthWidth * frontBoost;
        ctx.beginPath();
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l.alpha * shimmer * depthAlpha;
          const mx = (a.x + b.x) * 0.5;
          const my = (a.y + b.y) * 0.5;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const nx = -dy / len;
          const ny = dx / len;
          const wobble = Math.sin(elapsed * 3.8 + l.phase) * LINK_WOBBLE;
          const flow = 0.68 + Math.sin(elapsed * LINK_FLOW_SPEED + l.phase * 1.7) * 0.32;
          const drift = Math.cos(elapsed * 4.6 + l.phase * 1.3) * LINK_DRIFT;
          const tx2 = dx / len; const ty2 = dy / len;
          const cx2 = mx + nx * wobble + tx2 * drift;
          const cy2 = my + ny * wobble + ty2 * drift;
          // store per-link computed values for reuse in passes 2 & 3
          l._cx2 = cx2; l._cy2 = cy2; l._al = al; l._flow = flow;
          l._pulse = 0.72 + Math.sin(elapsed * 6.3 + l.phase * 2.4) * 0.28;
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
        }
        // Outer pass uses per-link alpha — must stroke individually (alpha varies per link)
        // But we can at least skip shadowBlur which is the heaviest cost
        ctx.restore();

        // Stroke individually but skip redundant state changes
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // Disable shadow for inner passes on mobile — saves ~40% GPU time
        if (!IS_MOBILE) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l._al;
          const pulse = l._pulse;
          const flow = l._flow;
          const cx2 = l._cx2;
          const cy2 = l._cy2;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${outerColor},${al * 0.28 * flow})`;
          ctx.lineWidth = (1.95 + pulse * 0.16) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${mainColor},${al * 0.5 * pulse})`;
          ctx.lineWidth = (1.2 + pulse * 0.14) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${coreColor},${al * 0.64 * flow})`;
          ctx.lineWidth = (0.84 + pulse * 0.1) * depthWidth * frontBoost;
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    function drawActiveRays(elapsed) {
      if (!bfsReady) return;
      ctx.save();
      ctx.lineCap = 'round';

      for (let i = activeRays.length - 1; i >= 0; i--) {
        const ray = activeRays[i];
        if (ray.done) continue;

        const t = (elapsed - ray.startTime) / ray.dur;
        if (t <= 0) continue;
        if (t >= 1.15) { ray.done = true; continue; }

        const progress = Math.min(1, t);
        const fromP = particles[ray.fromIdx];
        const toP = particles[ray.toIdx];

        // Interpolate ray tip position
        const tipX = fromP.x + (toP.x - fromP.x) * progress;
        const tipY = fromP.y + (toP.y - fromP.y) * progress;

        // Tail fades — ray is short, bright at tip, fading behind
        const tailLen = 0.35; // fraction of total distance shown as tail
        const tailT = Math.max(0, progress - tailLen);
        const tailX = fromP.x + (toP.x - fromP.x) * tailT;
        const tailY = fromP.y + (toP.y - fromP.y) * tailT;

        // Fade out as the ray completes (t > 1)
        const fadeOut = t > 1 ? 1 - (t - 1) / 0.15 : 1;
        const intensity = fadeOut * Math.min(1, progress * 3);

        // Outer glow
        const grd = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
        grd.addColorStop(0, `rgba(255,80,140,0)`);
        grd.addColorStop(0.6, `rgba(255,120,180,${0.35 * intensity})`);
        grd.addColorStop(1, `rgba(255,255,255,${0.95 * intensity})`);

        ctx.shadowColor = 'rgba(255,80,160,0.9)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = grd;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Bright core
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(fromP.x + (toP.x - fromP.x) * Math.max(0, progress - 0.12), fromP.y + (toP.y - fromP.y) * Math.max(0, progress - 0.12));
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = `rgba(255,240,250,${0.98 * intensity})`;
        ctx.lineWidth = 1.0;
        ctx.stroke();

        // Bright tip dot
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(tipX, tipY, 2.2 * intensity, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${intensity})`;
        ctx.fill();
      }

      ctx.restore();
    }

    function getContourPointCW(progress) {
      const start = INTERIOR_COUNT;
      const n = CONTOUR_COUNT;
      const wrapped = ((progress % n) + n) % n;
      const base = wrapped; // counter-clockwise direction
      const i0 = Math.floor(base) % n;
      const i1 = (i0 + 1) % n;
      const frac = base - Math.floor(base);
      const a = particles[start + i0];
      const b = particles[start + i1];
      return {
        x: a.x + (b.x - a.x) * frac,
        y: a.y + (b.y - a.y) * frac
      };
    }

    function drawContourThread(elapsed) {
      const contourStartAt = WAVE_START + CONTOUR_START;
      if (elapsed <= contourStartAt) return;
      const n = BND_FIXED.length; // 900
      if (n < 2) return;

      // Notch = i=0 (t=0, top center dip), Bottom = i=n/2 (t=PI, bottom tip)
      // Each arc covers exactly n/2 points — perfect symmetry
      const topIdx = 0;
      const half = Math.floor(n / 2); // 450

      const dur = CONTOUR_COUNT * CONTOUR_STEP;
      const progress = Math.min(1, Math.max(0, (elapsed - contourStartAt) / dur));
      if (progress <= 0) return;

      const visible = Math.round(progress * half); // same for both arcs

      // Unified breathing — same formula for both animation and completed states
      const glowStrength = Math.max(0.1, Math.min(1, ANIM.contour.glow));
      const breathe = (0.82 + Math.sin(elapsed * 2.4) * 0.18) * glowStrength;

      function drawNeonLine(pts, closed) {
        if (pts.length < 2) return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // On mobile: skip the two heavy outer glow passes (blur 22 & 11) to save GPU
        const passes = IS_MOBILE ? [
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`, w: 2.2 },
          { blur: 1,  color: `rgba(255,80,140,${0.85 * breathe})`, w: 0.9 },
        ] : [
          { blur: 22, color: `rgba(255,40,110,${0.28 * breathe})`,  w: 11  },
          { blur: 11, color: `rgba(255,200,230,${0.45 * breathe})`, w: 5   },
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`, w: 2.2 },
          { blur: 2,  color: `rgba(255,80,140,${0.85 * breathe})`, w: 0.9 },
        ];
        for (const p of passes) {
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          if (closed) ctx.closePath();
          ctx.shadowColor = 'rgba(220,20,70,1)';
          ctx.shadowBlur = p.blur;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.w;
          ctx.stroke();
        }
        ctx.restore();
      }

      if (progress >= 1) {
        // Full closed heart — same unified neon passes
        drawNeonLine(BND_FIXED, true);
        return;
      }

      // CW arc: 0 → 1 → 2 → ... → visible  (right side going down)
      const cwPts = [];
      for (let k = 0; k <= visible; k++) cwPts.push(BND_FIXED[k]);

      // CCW arc: 0 → n-1 → n-2 → ... → n-visible  (left side going down)
      // Skip index 0 (already in cwPts) to avoid double-rendering the notch point
      const ccwPts = [];
      for (let k = 1; k <= visible; k++) ccwPts.push(BND_FIXED[(n - k) % n]);

      // Draw as single merged path: ccw reversed + cw, so it's one continuous stroke from left tip → notch → right tip
      // This prevents the neon glow from stacking double at the starting notch point
      const mergedPts = [...ccwPts.slice().reverse(), ...cwPts];
      drawNeonLine(mergedPts, false);
    }



    // ── DRAW PULSING HEART IN CENTER ────────────────────────────────
    // ── ALINA — имя внутри сердца, та же анимация что I Love You ─────
    let alinaState = 'idle'; // idle → drawing → done
    let alinaStartTime = null;

    function drawPulseHeart(animElapsed) {
      if (!pulseActive) return;

      // Запускаем анимацию при первом вызове
      if (alinaState === 'idle') {
        alinaState    = 'drawing';
        alinaStartTime = animElapsed;
      }

      const elapsed = animElapsed - alinaStartTime;

      // Параметры шрифта
      const fontSize = Math.round(Math.max(28, Math.min(64, sc * 2.8)));
      const font     = `400 ${fontSize}px 'Great Vibes', cursive`;

      // Длина пути (приблизительно для "Alina")
      const pathLen  = fontSize * 14;
      const drawDur  = CONFIG.alina.drawSpeed;
      const glowDur  = 0.8;

      // Прогресс рисования [0..1]
      const drawT  = Math.min(1, elapsed / drawDur);
      const offset = pathLen * (1 - drawT);

      // После рисования — нарастание свечения
      const glowT  = elapsed > drawDur ? Math.min(1, (elapsed - drawDur) / glowDur) : 0;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.font         = font;
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';

      const fadeIn = Math.min(1, elapsed / 0.25);
      // glowT начинает нарастать согласно glowSpeed из CONFIG
      const glowStart = 1 - CONFIG.alina.glowSpeed;
      const glowT2 = Math.min(1, Math.max(0, (drawT - glowStart) / (1 - glowStart)));

      // Слой 0 — лёгкий широкий ореол
      ctx.globalAlpha  = fadeIn * glowT2 * 0.10;
      ctx.lineWidth    = 9;
      ctx.strokeStyle  = 'rgba(255,80,150,1)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      // Слой 1 — средний розовый
      ctx.globalAlpha  = fadeIn * glowT2 * 0.22;
      ctx.lineWidth    = 4;
      ctx.strokeStyle  = 'rgba(255,120,180,1)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      // Слой 2 — белое ядро
      ctx.globalAlpha  = fadeIn * (0.8 + glowT2 * 0.2);
      ctx.lineWidth    = 1.2;
      ctx.strokeStyle  = 'rgba(255,240,250,0.95)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.shadowBlur  = 0;
      ctx.restore();
    }

    // updatePulse и drawPulseFlash оставляем пустыми
    function updatePulse(animElapsed) {}
    function drawPulseFlash(animElapsed) {}

    function frame() {
      if (!started) return;
      const now = Date.now();
      const elapsed = (now - start) / 1000;
      const realDt = Math.min(0.1, (now - last) / 1000); // реальное время кадра, но не больше 100мс
      const animElapsed = elapsed * MAIN_TIME_SCALE;
      last = now;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // Accumulator: догоняем пропущенные шаги физики если кадр был тяжёлым
      physicsAccumulator += realDt;
      let steps = 0;
      while (physicsAccumulator >= PHYSICS_STEP && steps < 4) {
        const animDt = PHYSICS_STEP * MAIN_TIME_SCALE;

        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];

          // Interior particles are handled by updateInteriorNetwork (BFS wave)
          if (!p.isContour && i < INTERIOR_COUNT) continue;

          const baseStart = WAVE_START + p.spawnAt;
          const st = p.isContour
            ? baseStart
            : NETWORK_START + p.spawnAt;

          if (animElapsed >= st && !p.born) {
            p.born = true;
            p.bornTime = animElapsed;
          }

          if (!p.born) continue;

          p.alpha = ease((animElapsed - p.bornTime) / BIRTH_DUR);

          // Contour particles are fixed in place — no spring movement, appear via alpha only
          p.x = p.tx;
          p.y = p.ty;
        }

        updateInteriorNetwork(animDt, animElapsed);
        physicsAccumulator -= PHYSICS_STEP;
        steps++;
      }

      if (!textStarted && animElapsed >= TEXT_START) {
        startText(animElapsed);
      }

      // Schedule BFS rays once per frame (not in physics loop to avoid duplicates)
      scheduleBfsRays(animElapsed);

      // Activate alina name drawing
      if (!pulseActive && animElapsed > CONFIG.alina.startAt) {
        pulseActive = true;
        lastBeatTime = animElapsed - PULSE_INTERVAL; // fire first beat immediately
      }

      updatePulse(animElapsed);

      ctx.save();
      clipToHeartShape();
      drawVolumeFog(animElapsed);
      drawInteriorNetwork(animElapsed);
      drawPulseFlash(animElapsed);
      drawActiveRays(animElapsed);
      ctx.restore();
      drawParticles();
      drawContourThread(animElapsed);
      drawPulseHeart(animElapsed);
      updateAndDrawWordDust(animElapsed);
      requestAnimationFrame(frame);
    }

    // ── NEON OUTLINE PRELUDE ─────────────────────────────────────────
    // Words rendered as pure stroke (no fill) with layered neon glow.
    // Font: Raleway — thin for normal words, bold for accent.
    // Animation: word-by-word fade-in, breathing hold, fade-out.

    // Fonts already preloaded in <head>

    const NEON_FONT_NORMAL = () => `700 ${Math.round(Math.max(28, Math.min(58, window.innerWidth * 0.054)))}px 'Raleway', sans-serif`;
    const NEON_FONT_ACCENT = () => `700 ${Math.round(Math.max(38, Math.min(80, window.innerWidth * 0.07)))}px 'Raleway', sans-serif`;

    const FADE_IN_DUR  = CONFIG.prelude1.fadeIn;
    const FADE_OUT_DUR = CONFIG.prelude1.fadeOut;
    const GLOW_PULSE   = 4.6;

    let neonWords = [];
    let preludeStartTime = null;
    let preludeActive    = false;
    let preludeRAF       = null;

    function buildNeonWords() {
      neonWords = [];
      const pW = window.innerWidth;

      function collectLine(containerEl, part1Sel, part2Sel, cfg) {
        const part1Els = Array.from(containerEl.querySelectorAll(part1Sel));
        const part2Els = Array.from(containerEl.querySelectorAll(part2Sel));
        if (!part1Els.length) return;

        const maxP1DelayMs = Math.max(...part1Els.map(e => parseFloat(e.dataset.delay || 0)));
        const s       = cfg.delay;
        const p1Hide  = s + maxP1DelayMs / 1000 + cfg.part1HideAfter / 1000;
        const p2Show  = p1Hide + cfg.part2ShowAfter / 1000;
        const p2Hide  = p2Show + cfg.part2HideAfter / 1000;

        // Measure part1 words and compute X positions
        const off = document.createElement('canvas').getContext('2d');
        const fontN = NEON_FONT_NORMAL();
        const fontA = NEON_FONT_ACCENT();
        off.font = fontN;
        const GAP = off.measureText(' ').width * 0.9;

        const p1Texts  = part1Els.map(e => e.textContent.trim());
        const p1W      = p1Texts.map(t => { off.font = fontN; return off.measureText(t).width; });
        const p1Total  = p1W.reduce((a, b) => a + b, 0) + GAP * (p1Texts.length - 1);

        // Y from DOM rect (element is invisible but laid out)
        const p1Rects = part1Els.map(e => e.getBoundingClientRect());
        const lineY1  = p1Rects.reduce((s2, r) => s2 + r.top + r.height / 2, 0) / p1Rects.length;

        let curX = pW / 2 - p1Total / 2;
        // fadeOutStart одинаковый для всей группы — все исчезают вместе
        const p1FadeOutStart = p1Hide - cfg.part1HideAfter / 1000 * 0.0 + (maxP1DelayMs / 1000);
        part1Els.forEach((el, i) => {
          const dMs = parseFloat(el.dataset.delay || 0);
          neonWords.push({
            text   : p1Texts[i],
            font   : fontN,
            isAccent: false,
            cx     : curX + p1W[i] / 2,
            cy     : lineY1,
            showAt : s + dMs / 1000,
            hideAt : p1Hide,
            fadeOutStart: p1Hide - cfg.part1HideAfter / 1000  // общий момент начала fadeOut
          });
          curX += p1W[i] + GAP;
        });

        // Part2 words (accent)
        if (part2Els.length) {
          const p2Texts = part2Els.map(e => e.textContent.trim());
          const p2W     = p2Texts.map(t => { off.font = fontA; return off.measureText(t).width; });
          const p2Total = p2W.reduce((a, b) => a + b, 0) + GAP * (p2Texts.length - 1);
          const p2Rects = part2Els.map(e => e.getBoundingClientRect());
          const lineY2  = p2Rects.reduce((s2, r) => s2 + r.top + r.height / 2, 0) / p2Rects.length;
          let p2X = pW / 2 - p2Total / 2;
          part2Els.forEach((el, i) => {
            neonWords.push({
              text   : p2Texts[i],
              font   : fontA,
              isAccent: true,
              cx     : p2X + p2W[i] / 2,
              cy     : lineY2,
              showAt : p2Show,
              hideAt : p2Hide
            });
            p2X += p2W[i] + GAP;
          });
        }
      }

      collectLine(preludeEl,  '.p1-part1', '.p1-part2', ANIM.preludeFirst);
      collectLine(prelude2El, '.p2-part1', '.p2-part2', ANIM.preludeSecond);
    }

    function drawNeonWord(word, alpha, elapsed) {
      if (alpha <= 0.005) return;
      pCtx.save();
      pCtx.imageSmoothingEnabled = true;
      pCtx.imageSmoothingQuality = 'high';
      pCtx.font         = word.font;
      pCtx.textAlign    = 'center';
      pCtx.textBaseline = 'middle';

      const pulse = 0.84 + Math.sin(elapsed * GLOW_PULSE + word.cx * 0.008) * 0.16;
      const gA    = alpha * pulse;
      const isA   = word.isAccent; // true for "You" and "Ever" only — pink neon
                                   // false for all other words — white neon

      if (isA) {
        // ── ACCENT: pink-magenta neon (You / Ever) ──────────────
        // Layer 1 — wide outer haze
        pCtx.shadowColor = 'rgba(255,0,130,1)';
        pCtx.shadowBlur  = 55;
        pCtx.lineWidth   = 3.5;
        pCtx.strokeStyle = `rgba(255,10,110,${gA * 0.38})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 2 — mid glow
        pCtx.shadowBlur  = 24;
        pCtx.lineWidth   = 2.5;
        pCtx.strokeStyle = `rgba(255,60,170,${gA * 0.72})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 3 — sharp neon edge
        pCtx.shadowBlur  = 9;
        pCtx.lineWidth   = 1.5;
        pCtx.strokeStyle = `rgba(255,100,200,${gA})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 4 — bright core hairline
        pCtx.shadowBlur  = 2;
        pCtx.lineWidth   = 0.5;
        pCtx.strokeStyle = `rgba(255,230,248,${alpha * 0.92})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

      } else {
        // ── NORMAL: pure white neon (all other words) ─────────────
        // Layer 1 — wide outer haze
        pCtx.shadowColor = 'rgba(255,255,255,1)';
        pCtx.shadowBlur  = 40;
        pCtx.lineWidth   = 2.6;
        pCtx.strokeStyle = `rgba(220,220,220,${gA * 0.25})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 2 — mid glow
        pCtx.shadowBlur  = 18;
        pCtx.lineWidth   = 1.9;
        pCtx.strokeStyle = `rgba(240,240,240,${gA * 0.55})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 3 — sharp white edge
        pCtx.shadowBlur  = 7;
        pCtx.lineWidth   = 1.1;
        pCtx.strokeStyle = `rgba(255,255,255,${gA})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 4 — bright core hairline
        pCtx.shadowBlur  = 2;
        pCtx.lineWidth   = 0.5;
        pCtx.strokeStyle = `rgba(255,255,255,${alpha * 0.95})`;
        pCtx.strokeText(word.text, word.cx, word.cy);
      }

      pCtx.restore();
    }

    function drawPreludeFrame(now) {
      if (!preludeActive) return;
      const elapsed = (now - preludeStartTime) / 1000;
      pCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      for (const word of neonWords) {
        if (elapsed < word.showAt || elapsed > word.hideAt) continue;
        const fadeInT  = Math.min(1, (elapsed - word.showAt) / FADE_IN_DUR);
        // fadeOutStart: общий для всей группы — все исчезают одновременно
        const foStart  = word.fadeOutStart !== undefined ? word.fadeOutStart : (word.hideAt - FADE_OUT_DUR);
        const fadeOutT = Math.min(1, Math.max(0, (elapsed - foStart) / FADE_OUT_DUR));
        const eIn      = 1 - Math.pow(1 - fadeInT, 3);
        const eOut     = Math.pow(1 - fadeOutT, 2);
        drawNeonWord(word, eIn * eOut, elapsed);
      }

      preludeRAF = requestAnimationFrame(drawPreludeFrame);
    }

    function startPreludeAnimation() {
      requestAnimationFrame(() => {
        buildNeonWords();
        preludeStartTime = performance.now();
        preludeActive    = true;
        preludeRAF       = requestAnimationFrame(drawPreludeFrame);
      });
    }

    function stopPreludeAnimation() {
      preludeActive = false;
      if (preludeRAF) cancelAnimationFrame(preludeRAF);
      pCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }

    function startExperience() {
      if (started || startPending) return;
      startPending = true;

      // Разблокируем аудио сразу в момент tap — iOS требует play() в user gesture
      bgMusic.currentTime = 0;
      bgMusic.play().then(() => {
        bgMusic.pause(); // сразу ставим на паузу — запустим после эмодзи
      }).catch(() => { });

      introEl.classList.add('exiting');

      window.setTimeout(() => {
        if (started) return;
        introEl.classList.add('hidden');

        // Запускаем музыку после исчезновения эмодзи
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => { });

        // Start particle prelude
        startPreludeAnimation();

        // ── MAIN ANIMATION ─────────────────────────────────────
        const mainStartDelay = MAIN_ANIMATION_START_AT_SEC * 1000;
        window.setTimeout(() => {
          stopPreludeAnimation();
          started = true;
          resize();
          frame();
        }, mainStartDelay);
      }, 560);
    }

    window.addEventListener('resize', resize);
    startBtn.addEventListener('click', startExperience);

  </script>