<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style"
    href="https://fonts.googleapis.com/css2?family=Raleway:wght@200;300;600;700&family=Great+Vibes&display=swap">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Raleway:wght@200;300;600;700&family=Great+Vibes&display=swap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I Love You</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    #intro {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    #intro.hidden {
      opacity: 0;
      pointer-events: none;
      transition: opacity 480ms ease;
    }

    #intro.exiting {
      pointer-events: none;
      animation: introFade 420ms ease forwards 180ms;
    }

    #intro.exiting #startBtn {
      animation: introExit 540ms cubic-bezier(.2,.9,.2,1) forwards;
    }

    /* ── DISCLAIMER ─────────────────────────────────────────────────── */
    #disclaimer {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 28px;
      text-align: center;
      animation: disclaimerIn 1s cubic-bezier(0.16,1,0.3,1) forwards;
    }

    #disclaimer.hiding {
      animation: disclaimerOut 0.6s ease forwards;
      pointer-events: none;
    }

    #disclaimer .airpods-icon {
      width: clamp(64px, 16vw, 96px);
      opacity: 0.92;
      filter: drop-shadow(0 0 16px rgba(255,60,140,0.5));
      animation: airpodsPulse 2.4s ease-in-out infinite;
    }

    #disclaimer .disc-text {
      color: rgba(255,255,255,0.55);
      font-family: 'Georgia', serif;
      font-size: clamp(14px, 3vw, 18px);
      line-height: 1.8;
      letter-spacing: 0.06em;
      max-width: min(300px, 76vw);
    }

    #disclaimer .disc-text em {
      color: rgba(255,100,160,0.85);
      font-style: normal;
    }

    /* ── START BUTTON ────────────────────────────────────────────────── */
    #startBtn {
      border: none;
      background: transparent;
      color: rgba(255,80,150,0.9);
      font-family: 'Georgia', serif;
      font-size: clamp(13px, 2.8vw, 17px);
      letter-spacing: 0.22em;
      text-transform: uppercase;
      cursor: pointer;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    #startBtn.visible {
      pointer-events: auto;
      animation: btnFadeIn 1s cubic-bezier(0.16,1,0.3,1) forwards;
    }

    #startBtn .heart-ring {
      width: clamp(72px, 18vw, 100px);
      height: clamp(72px, 18vw, 100px);
      border-radius: 50%;
      border: 1px solid rgba(255,60,130,0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      animation: ringPulse 2.2s ease-in-out infinite;
    }

    #startBtn .heart-ring::before {
      content: '';
      position: absolute;
      inset: -8px;
      border-radius: 50%;
      border: 1px solid rgba(255,60,130,0.12);
      animation: ringPulse 2.2s ease-in-out infinite 0.3s;
    }

    #startBtn .heart-svg {
      width: clamp(30px, 7vw, 42px);
      filter: drop-shadow(0 0 8px rgba(255,60,140,0.7));
      animation: heartBeat 2.2s ease-in-out infinite;
    }

    #startBtn .label {
      display: block;
      font-size: clamp(11px, 2.4vw, 14px);
      letter-spacing: 0.28em;
      color: rgba(255,255,255,0.35);
    }

    @keyframes disclaimerIn {
      from { opacity: 0; transform: translateY(18px); }
      to   { opacity: 1; transform: translateY(0);    }
    }

    @keyframes disclaimerOut {
      from { opacity: 1; transform: translateY(0);     }
      to   { opacity: 0; transform: translateY(-14px); }
    }

    @keyframes airpodsPulse {
      0%, 100% { transform: scale(1);    filter: drop-shadow(0 0 16px rgba(255,60,140,0.5)); }
      50%       { transform: scale(1.05); filter: drop-shadow(0 0 26px rgba(255,80,160,0.8)); }
    }

    @keyframes btnFadeIn {
      from { opacity: 0; transform: translateY(12px); }
      to   { opacity: 1; transform: translateY(0);    }
    }

    @keyframes ringPulse {
      0%, 100% { transform: scale(1);    opacity: 1;   }
      50%       { transform: scale(1.06); opacity: 0.7; }
    }

    @keyframes heartBeat {
      0%, 100% { transform: scale(1);    }
      15%       { transform: scale(1.12); }
      30%       { transform: scale(1);    }
      45%       { transform: scale(1.06); }
      60%       { transform: scale(1);    }
    }

    @keyframes introExit {
      0%   { transform: scale(1);    opacity: 1; }
      34%  { transform: scale(1.08); opacity: 1; }
      100% { transform: scale(0.82); opacity: 0; }
    }

    @keyframes introFade {
      from { opacity: 1; }
      to   { opacity: 0; }
    }

    /* ── I LOVE YOU — handwriting SVG ──────────────────────────────── */
    #txt {
      position: fixed;
      bottom: 60px;
      width: 100%;
      text-align: center;
      pointer-events: none;
      white-space: nowrap;
      /* hidden — replaced by SVG canvas below */
      opacity: 0;
      font-size: 0;
    }

    #iloveyou-svg {
      position: fixed;
      bottom: 40px;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none;
      overflow: visible;
      display: block;
    }

    /* Each word group */
    .ily-word {
      opacity: 0;
    }

    /* The neon stroke that draws itself */
    .ily-stroke {
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .ily-fill {
      display: none;
    }

    @keyframes ilyDraw {
      from {
        stroke-dashoffset: var(--dash-len);
      }

      to {
        stroke-dashoffset: 0;
      }
    }

    @keyframes ilyGlow {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes ilyWordIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    #txt::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%) scaleX(0.25);
      transform-origin: center;
      bottom: -8px;
      width: min(380px, 72vw);
      height: 2px;
      background: linear-gradient(90deg, rgba(220, 20, 80, 0), rgba(255, 60, 130, 1.00), rgba(220, 20, 80, 0));
      filter: drop-shadow(0 0 8px rgba(255, 40, 120, 0.90));
      opacity: 0;
    }

    #txt.line-on::after {
      animation: lineIn 850ms cubic-bezier(.2, .9, .2, 1) forwards, linePulse 2600ms ease-in-out infinite 850ms;
    }

    @keyframes lineIn {
      from {
        opacity: 0;
        transform: translateX(-50%) scaleX(0.25);
        filter: drop-shadow(0 0 2px rgba(180, 40, 90, .30));
      }

      to {
        opacity: .9;
        transform: translateX(-50%) scaleX(1);
        filter: drop-shadow(0 0 10px rgba(235, 90, 140, .85));
      }
    }

    @keyframes linePulse {

      0%,
      100% {
        opacity: .88;
        filter: drop-shadow(0 0 10px rgba(210, 60, 110, .82));
      }

      50% {
        opacity: 1;
        filter: drop-shadow(0 0 14px rgba(235, 90, 140, .92));
      }
    }

    @media (max-width: 520px) {
      #txt {
        letter-spacing: 0.15em;
      }
    }

    /* ── PRELUDE: canvas overlay ────────────────────────────────────── */
    #prelude-canvas {
      position: fixed;
      inset: 0;
      z-index: 15;
      pointer-events: none;
    }

    /* Hidden text elements used only to measure word geometry */
    #prelude,
    #prelude2 {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      opacity: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #prelude-part1,
    #prelude-part2,
    #prelude2-part1,
    #prelude2-part2 {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      text-align: center;
    }

    #prelude .word,
    #prelude2 .word {
      display: inline-block;
      margin: 0 0.18em;
      font-family: 'Georgia', serif;
      font-size: clamp(26px, 5.2vw, 56px);
      font-style: italic;
      white-space: nowrap;
    }

    #prelude .word.accent,
    #prelude2 .word.accent {
      font-size: clamp(32px, 6.5vw, 72px);
    }
  </style>
</head>

<body>
  <div id="intro">
    <div id="disclaimer">
      <!-- AirPods Pro SVG icon -->
      <svg class="airpods-icon" viewBox="0 0 128 128" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M44.4321 34.7752C46.9601 33.1966 49.4488 32.7495 51.503 33.5712C57.4743 35.9596 59.3424 40.9763 59.8382 44.0411C60.4667 47.926 59.4513 51.5275 58.0702 53.9197C56.5144 56.6147 53.8944 58.696 50.8835 59.9004C47.8387 61.1183 41.8926 62.5764 36.492 58.7188C34.5075 57.3013 33.7108 55.0475 33.9248 52.2169C34.1398 49.3727 35.3774 46.003 37.3987 42.502C39.4086 39.0207 41.9092 36.3506 44.4321 34.7752ZM43.9024 33.927C41.2119 35.6071 38.6057 38.4114 36.5327 42.002C34.471 45.5728 33.1582 49.0913 32.9277 52.1415C32.6961 55.2054 33.5587 57.8525 35.9107 59.5325C41.7333 63.6915 48.1049 62.0889 51.2549 60.8289C54.4389 59.5552 57.2507 57.3393 58.9363 54.4197C60.4163 51.8559 61.4955 48.0235 60.8254 43.8814C60.2981 40.6221 58.293 35.2101 51.8744 32.6427C49.4191 31.6606 46.5877 32.2501 43.9024 33.927Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M58.5624 44.6573C58.7004 44.4182 58.6185 44.1124 58.3794 43.9743C57.2157 43.3025 55.7154 43.7963 54.3618 44.7657C52.9675 45.7641 51.5381 47.3897 50.3792 49.397C49.2204 51.4042 48.5272 53.4549 48.3597 55.1616C48.197 56.8186 48.5195 58.3648 49.6831 59.0366C49.9223 59.1747 50.2281 59.0928 50.3661 58.8536C50.5042 58.6145 50.4223 58.3087 50.1831 58.1706C49.569 57.816 49.1993 56.844 49.3549 55.2593C49.5055 53.7244 50.1408 51.8099 51.2453 49.897C52.3497 47.984 53.69 46.4766 54.944 45.5787C56.2386 44.6516 57.2652 44.4857 57.8794 44.8403C58.1185 44.9784 58.4243 44.8965 58.5624 44.6573Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M58.0117 49.0102C58.032 50.2124 57.6491 51.6732 56.8312 53.0897C56.0134 54.5063 54.9397 55.5683 53.8885 56.1519C52.8271 56.7411 51.8748 56.8041 51.1978 56.4132C50.5207 56.0223 50.0992 55.1661 50.0788 53.9523C50.0586 52.7501 50.4415 51.2893 51.2593 49.8728C52.0771 48.4563 53.1508 47.3942 54.202 46.8107C55.2634 46.2214 56.2157 46.1584 56.8927 46.5493C57.5698 46.9402 57.9913 47.7964 58.0117 49.0102ZM59.0116 48.9934C58.988 47.5928 58.4935 46.3188 57.3927 45.6833C56.292 45.0477 54.9414 45.2564 53.7167 45.9363C52.4818 46.6219 51.2861 47.8263 50.3933 49.3728C49.5004 50.9193 49.0552 52.5569 49.0789 53.9691C49.1025 55.3697 49.597 56.6437 50.6978 57.2792C51.7985 57.9148 53.1491 57.7061 54.3739 57.0262C55.6088 56.3406 56.8044 55.1362 57.6973 53.5897C58.5901 52.0433 59.0354 50.4056 59.0116 48.9934Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M20.4631 53.1177C20.309 53.2072 20.2141 53.3719 20.2141 53.5502L20.2141 85.7639C20.2141 87.0855 20.5713 88.6184 21.7043 89.8234C22.8441 91.0356 24.6967 91.8393 27.5285 91.8393C30.408 91.8393 32.2637 91.0372 33.3929 89.8211C34.515 88.6127 34.843 87.0778 34.843 85.7639C34.8428 83.7363 34.8429 75.0653 34.8429 67.1347C34.8429 63.4343 34.843 59.895 34.843 57.2671C34.843 57.0039 34.6389 56.7858 34.3762 56.7682C31.31 56.5638 25.2029 55.5393 20.9621 53.116C20.8074 53.0276 20.6173 53.0283 20.4631 53.1177ZM33.843 57.7306C33.843 60.3037 33.8429 63.6476 33.8429 67.1346C33.8429 75.0653 33.8428 83.7364 33.843 85.7639C33.843 86.928 33.5515 88.1807 32.6601 89.1406C31.776 90.0928 30.2243 90.8393 27.5285 90.8393C24.8863 90.8393 23.3317 90.0943 22.4328 89.1383C21.527 88.175 21.2141 86.9202 21.2141 85.7639L21.2141 54.3892C25.3609 56.5164 30.7763 57.4711 33.843 57.7306Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M20.1494 18.122C23.9743 17.072 28.9748 17.2066 35.4038 19.6558C44.7955 23.2336 48.9881 30.2117 49.9788 32.9856C50.0717 33.2456 50.3578 33.3812 50.6179 33.2883C50.8779 33.1954 51.0134 32.9093 50.9206 32.6493C49.8463 29.6412 45.4634 22.4179 35.7598 18.7213C29.1795 16.2145 23.9583 16.0394 19.8847 17.1576C15.8107 18.276 12.9346 20.6742 11.0215 23.225C7.19949 28.3211 5.28019 38.4948 11.6569 46.1469C14.7807 49.8955 17.6949 52.4903 21.238 54.3323C24.7759 56.1716 28.906 57.2419 34.4324 57.9955C34.706 58.0328 34.9581 57.8412 34.9954 57.5676C35.0327 57.294 34.8412 57.0419 34.5675 57.0046C29.0939 56.2582 25.092 55.2089 21.6992 53.445C18.3116 51.6838 15.4963 49.1921 12.4251 45.5067C6.41198 38.2909 8.20965 28.6408 11.8215 23.825C13.6254 21.4198 16.3248 19.1719 20.1494 18.122Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M25.7937 18.1743C25.758 18.4482 25.9511 18.6991 26.2249 18.7348C37.4054 20.1931 44.2672 28.6741 46.2856 32.711C46.4091 32.958 46.7095 33.0581 46.9565 32.9346C47.2035 32.8111 47.3036 32.5108 47.1801 32.2638C45.0686 28.0408 37.9711 19.2585 26.3542 17.7432C26.0804 17.7075 25.8295 17.9005 25.7937 18.1743Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.9768 23.3534C16.2922 22.3001 14.0726 22.812 13.0194 24.4966C11.9661 26.1813 12.4779 28.4009 14.1626 29.4541L18.184 31.9684C19.8686 33.0216 22.0882 32.5098 23.1414 30.8251C24.1947 29.1405 23.6829 26.9209 21.9982 25.8676L17.9768 23.3534ZM13.8673 25.0268C14.6278 23.8104 16.2303 23.4408 17.4467 24.2013L21.4681 26.7156C22.6845 27.4761 23.054 29.0786 22.2935 30.295C21.533 31.5114 19.9305 31.8809 18.7141 31.1204L14.6927 28.6062C13.4763 27.8457 13.1068 26.2431 13.8673 25.0268Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M17.9768 23.3534C16.2922 22.3001 14.0726 22.812 13.0194 24.4966C11.9661 26.1813 12.4779 28.4009 14.1626 29.4541L23.2114 35.1116C24.896 36.1648 27.1156 35.653 28.1689 33.9683C29.2221 32.2837 28.7103 30.0641 27.0256 29.0109L17.9768 23.3534ZM13.8673 25.0268C14.6278 23.8104 16.2303 23.4408 17.4467 24.2013L26.4955 29.8588C27.7119 30.6193 28.0814 32.2218 27.3209 33.4382C26.5604 34.6546 24.9579 35.0241 23.7415 34.2637L14.6927 28.6062C13.4763 27.8457 13.1068 26.2431 13.8673 25.0268Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M83.5679 54.599C81.0399 53.0204 78.5512 52.5733 76.497 53.395C70.5257 55.7835 68.6576 60.8001 68.1618 63.8649C67.5333 67.7499 68.5487 71.3513 69.9298 73.7436C71.4856 76.4385 74.1056 78.5199 77.1165 79.7242C80.1613 80.9422 86.1074 82.4002 91.508 78.5426C93.4925 77.1252 94.2892 74.8714 94.0752 72.0408C93.8602 69.1966 92.6226 65.8269 90.6013 62.3259C88.5914 58.8446 86.0908 56.1745 83.5679 54.599ZM84.0976 53.7508C86.7881 55.4309 89.3943 58.2353 91.4673 61.8259C93.529 65.3967 94.8418 68.9151 95.0723 71.9654C95.3039 75.0292 94.4413 77.6763 92.0893 79.3564C86.2667 83.5154 79.8951 81.9127 76.7451 80.6527C73.5611 79.3791 70.7493 77.1632 69.0637 74.2435C67.5837 71.6798 66.5045 67.8473 67.1746 63.7052C67.7019 60.446 69.707 55.0339 76.1256 52.4665C78.5809 51.4844 81.4123 52.074 84.0976 53.7508Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M69.4376 64.4812C69.2996 64.2421 69.3815 63.9363 69.6206 63.7982C70.7843 63.1264 72.2846 63.6202 73.6382 64.5896C75.0325 65.588 76.4619 67.2137 77.6208 69.2209C78.7796 71.2281 79.4728 73.2788 79.6403 74.9855C79.803 76.6425 79.4805 78.1887 78.3169 78.8605C78.0777 78.9986 77.7719 78.9167 77.6339 78.6775C77.4958 78.4384 77.5777 78.1326 77.8169 77.9945C78.431 77.6399 78.8007 76.6679 78.6451 75.0832C78.4945 73.5483 77.8592 71.6339 76.7547 69.7209C75.6503 67.8079 74.31 66.3006 73.056 65.4026C71.7614 64.4755 70.7348 64.3097 70.1206 64.6642C69.8815 64.8023 69.5757 64.7204 69.4376 64.4812Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M69.9885 68.8341C69.9683 70.0362 70.3512 71.4971 71.169 72.9136C71.9868 74.3301 73.0605 75.3921 74.1117 75.9757C75.1731 76.5649 76.1254 76.628 76.8025 76.2371C77.4795 75.8462 77.901 74.9899 77.9215 73.7762C77.9417 72.574 77.5588 71.1131 76.741 69.6966C75.9231 68.2801 74.8494 67.2181 73.7982 66.6345C72.7368 66.0453 71.7845 65.9823 71.1075 66.3731C70.4305 66.764 70.0089 67.6203 69.9885 68.8341ZM68.9886 68.8172C69.0122 67.4166 69.5068 66.1426 70.6075 65.5071C71.7083 64.8716 73.0588 65.0803 74.2836 65.7602C75.5185 66.4457 76.7141 67.6501 77.607 69.1966C78.4998 70.7431 78.9451 72.3808 78.9213 73.793C78.8978 75.1936 78.4032 76.4676 77.3025 77.1031C76.2017 77.7386 74.8511 77.5299 73.6264 76.85C72.3915 76.1645 71.1958 74.9601 70.303 73.4136C69.4101 71.8671 68.9649 70.2294 68.9886 68.8172Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M107.537 72.9416C107.691 73.031 107.786 73.1958 107.786 73.374L107.786 105.588C107.786 106.909 107.429 108.442 106.296 109.647C105.156 110.859 103.303 111.663 100.471 111.663C97.592 111.663 95.7363 110.861 94.6071 109.645C93.485 108.437 93.157 106.902 93.157 105.588C93.1572 103.56 93.1571 94.8892 93.1571 86.9585C93.1571 83.2581 93.157 79.7189 93.157 77.091C93.157 76.8278 93.3611 76.6096 93.6238 76.5921C96.69 76.3877 102.797 75.3632 107.038 72.9399C107.193 72.8515 107.383 72.8521 107.537 72.9416ZM94.157 77.5545C94.157 80.1275 94.1571 83.4714 94.1571 86.9585C94.1571 94.8891 94.1572 103.56 94.157 105.588C94.157 106.752 94.4485 108.005 95.3399 108.964C96.224 109.917 97.7757 110.663 100.471 110.663C103.114 110.663 104.668 109.918 105.567 108.962C106.473 107.999 106.786 106.744 106.786 105.588L106.786 74.213C102.639 76.3403 97.2237 77.295 94.157 77.5545Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M107.851 37.9458C104.026 36.8958 99.0254 37.0305 92.5964 39.4796C83.2047 43.0574 79.0121 50.0355 78.0214 52.8094C77.9285 53.0695 77.6424 53.205 77.3824 53.1121C77.1223 53.0193 76.9868 52.7332 77.0797 52.4731C78.154 49.4651 82.5369 42.2417 92.2404 38.5451C98.8208 36.0383 104.042 35.8633 108.116 36.9815C112.19 38.0998 115.066 40.4981 116.979 43.0489C120.801 48.1449 122.72 58.3187 116.343 65.9708C113.217 69.7226 110.053 72.4842 106.451 74.3686C102.847 76.2539 98.8326 77.2463 94.0263 77.4993C93.7505 77.5138 93.5152 77.302 93.5007 77.0263C93.4862 76.7505 93.698 76.5152 93.9737 76.5007C98.6674 76.2536 102.535 75.2883 105.987 73.4825C109.441 71.6757 112.507 69.0127 115.575 65.3306C121.588 58.1148 119.791 48.4647 116.179 43.6489C114.375 41.2437 111.675 38.9957 107.851 37.9458Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M102.207 37.9982C102.242 38.272 102.049 38.5229 101.775 38.5587C90.5949 40.017 83.7331 48.4979 81.7146 52.5348C81.5911 52.7818 81.2908 52.8819 81.0438 52.7584C80.7968 52.635 80.6967 52.3346 80.8202 52.0876C82.9317 47.8646 90.0291 39.0823 101.646 37.5671C101.92 37.5313 102.171 37.7244 102.207 37.9982Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M110.023 43.1773C111.708 42.124 113.928 42.6358 114.981 44.3205C116.034 46.0052 115.522 48.2247 113.838 49.278L109.816 51.7922C108.132 52.8455 105.912 52.3336 104.859 50.649C103.805 48.9643 104.317 46.7448 106.002 45.6915L110.023 43.1773ZM114.133 44.8506C113.372 43.6343 111.77 43.2647 110.554 44.0252L106.532 46.5394C105.316 47.2999 104.946 48.9025 105.707 50.1189C106.467 51.3352 108.07 51.7048 109.286 50.9443L113.308 48.4301C114.524 47.6696 114.893 46.067 114.133 44.8506Z" fill="rgba(255,80,150,0.85)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M110.023 43.1773C111.708 42.124 113.928 42.6358 114.981 44.3205C116.034 46.0052 115.522 48.2247 113.838 49.278L104.789 54.9354C103.104 55.9887 100.885 55.4769 99.8314 53.7922C98.7781 52.1075 99.2899 49.888 100.975 48.8347L110.023 43.1773ZM114.133 44.8506C113.372 43.6343 111.77 43.2647 110.554 44.0252L101.505 49.6826C100.288 50.4431 99.9188 52.0457 100.679 53.2621C101.44 54.4784 103.042 54.848 104.259 54.0875L113.308 48.4301C114.524 47.6696 114.893 46.067 114.133 44.8506Z" fill="rgba(255,80,150,0.85)"/>
      </svg>
      <div class="disc-text">
        Перед началом рекомендую<br>надеть наушники —<br><em>так почувствуешь всю атмосферу</em>
      </div>
    </div>
    <button id="startBtn" type="button" aria-label="Start animation">
      <div class="heart-ring">
        <svg class="heart-svg" viewBox="0 0 40 36" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M20 33C20 33 3 22 3 11.5C3 7.36 6.36 4 10.5 4C13.24 4 15.67 5.48 17.08 7.7L20 12L22.92 7.7C24.33 5.48 26.76 4 29.5 4C33.64 4 37 7.36 37 11.5C37 22 20 33 20 33Z" fill="rgba(255,60,130,0.15)" stroke="rgba(255,80,150,0.9)" stroke-width="1.2" stroke-linejoin="round"/>
        </svg>
      </div>
      <span class="label">нажми</span>
    </button>
  </div>

  <!-- Measurement-only prelude elements (opacity:0, z-index:-1) -->
  <!-- data-delay (мс) — задержка появления каждого слова от startAt прелюдии -->
  <div id="prelude" aria-hidden="true">
    <div id="prelude-part1">
      <span class="word p1-part1" data-delay="0">All</span>
      <span class="word p1-part1" data-delay="200">of</span>
      <span class="word p1-part1" data-delay="760">this</span>
      <span class="word p1-part1" data-delay="1250">is</span>
      <span class="word p1-part1" data-delay="1780">for</span>
    </div>
    <div id="prelude-part2">
      <span class="word accent p1-part2" data-delay="0">You</span>
    </div>
  </div>
  <div id="prelude2" aria-hidden="true">
    <div id="prelude2-part1">
      <span class="word p2-part1" data-delay="0">You</span>
      <span class="word p2-part1" data-delay="250">are</span>
      <span class="word p2-part1" data-delay="760">the</span>
      <span class="word p2-part1" data-delay="1300">best</span>
      <span class="word p2-part1" data-delay="1600">thing</span>
    </div>
    <div id="prelude2-part2">
      <span class="word accent p2-part2" data-delay="0">Ever</span>
    </div>
  </div>

  <canvas id="c"></canvas>
  <!-- Particle-prelude overlay canvas -->
  <canvas id="prelude-canvas"></canvas>

  <div id="txt" aria-label="I Love You">
    <span class="word highlight" data-delay="0">I</span>
    <span class="word highlight" data-delay="1450">Love</span>
    <span class="word highlight" data-delay="2750">You</span>
  </div>
  <!-- Handwriting SVG for I Love You — populated by JS -->
  <svg id="iloveyou-svg" aria-hidden="true"></svg>

  <script>
    // ╔══════════════════════════════════════════════════════════════════╗
    // ║                     🎛  НАСТРОЙКИ                               ║
    // ║  Все параметры анимации в одном месте. Меняй и обновляй.        ║
    // ╚══════════════════════════════════════════════════════════════════╝

    const CONFIG = {

      // ── 🎬 ПРЕЛЮДИЯ 1: "All of this is for" + "You" ───────────────────
      prelude1: {
        startAt: 8.9,   // секунд от старта до появления первого слова
        holdPart1: 400,   // мс удержания после последнего слова части 1
        overlapPart2: 200,   // мс — насколько раньше появляется "You" (перекрытие)
        holdPart2: 2000,  // мс удержания слова "You"
        fadeIn: 0.40,  // секунд — скорость появления каждого слова
        fadeOut: 0.40,  // секунд — скорость исчезновения
      },

      // ── 🎬 ПРЕЛЮДИЯ 2: "You are the best thing" + "Ever" ───────────
      prelude2: {
        startAt: 17.87, // секунд от старта
        holdPart1: 150,   // мс удержания части 1
        overlapPart2: 150,   // мс перекрытия с "You"
        holdPart2: 2000,  // мс удержания "You"
        fadeIn: 0.40,
        fadeOut: 0.40,
      },

      // ── 💎 PARTICLE NETWORK ─────────────────────────────────────────
      network: {
        startAt: 9.2,   // секунд — когда начинается BFS-волна
        bfsSpeed: 0.25,   // скорость волны (1.0 = нормально, 2.0 = вдвое быстрее)
        linkDist: 68,    // макс. расстояние между точками для создания связи (px)
        particleCount: 700,   // кол-во точек внутри (мобайл: 340)
        contourCount: 260,   // кол-во точек по контуру (мобайл: 180)
        nearMin: 0.74,  // мин. радиус размещения точек (доля от края)
        nearMax: 0.96,  // макс. радиус (0.96 = не касается контура)
      },

      // ── 💓 ПУЛЬСИРУЮЩЕЕ СЕРДЦЕ ──────────────────────────────────────
      pulse: {
        startAt: 19,
        interval: 1.35,  // секунд между ударами
        beatDur: 0.18,  // секунд — длительность одного удара
        waveSpeed: 320,   // px/сек — скорость волны от верхушки вниз
        waveDur: 0.45,  // секунд — как долго светится вспышка на точке/линии
        heartScale: 0.20,  // размер сердечка (доля от sc — масштаба формулы)
      },

      // ── 💬 "I LOVE YOU" ─────────────────────────────────────────────
      iLoveYou: {
        startAt: 14.2,    // секунд — когда начинает появляться "I"
        delayLove: 1.60,  // секунд после startAt — задержка "Love"
        delayYou: 3.5,   // секунд после startAt — задержка "You"
        drawSpeed: 1,     // скорость рисования (меньше = быстрее)
        glowSpeed: 0.2,   // скорость появления свечения (меньше = быстрее)
        glowDur: 0.9,   // секунд — нарастание неонового свечения
      },

      // ── 💫 "ALINA" ──────────────────────────────────────────────────
      alina: {
        startAt: 19.2,    // секунд — когда начинает рисоваться имя
        drawSpeed: 2.2,   // секунд на рисование (меньше = быстрее)
        glowSpeed: 0.98,   // скорость появления свечения (меньше = быстрее, 0.8 = с 80% рисования)
      },

      // ── ⏱ КОНТУР СЕРДЦА ─────────────────────────────────────────────
      contour: {
        startAt: 0.7,   // секунд — задержка перед рисованием контура
        speed: 0.27,  // скорость рисования контура
        glow: 5,     // яркость свечения контура во время анимаций
        finalGlowAt: 20.5,    // секунд — когда начинается финальная подсветка
        finalGlowSpeed: 2.5,   // секунд — скорость нарастания финального свечения
        finalGlowPower: 4,   // множитель яркости финального свечения (1 = как обычно, 4 = очень ярко)
      },

      // ── 🌐 ОБЩЕЕ ────────────────────────────────────────────────────
      global: {
        mainSpeed: 0.74,  // общая скорость анимации (timeScale)
        mainStartAt: 22.15, // секунд — когда запускается основная анимация
        musicVolume: 0.62,  // громкость музыки (0.0 – 1.0)
      },

    };
    // ╔══════════════════════════════════════════════════════════════════╗
    // ║              конец настроек — дальше не трогать                 ║
    // ╚══════════════════════════════════════════════════════════════════╝

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const pCanvas = document.getElementById('prelude-canvas');
    const pCtx = pCanvas.getContext('2d');

    // Resize prelude canvas to match window
    function resizePreludeCanvas() {
      pCanvas.width = window.innerWidth * (window.devicePixelRatio || 1);
      pCanvas.height = window.innerHeight * (window.devicePixelRatio || 1);
      pCanvas.style.width = window.innerWidth + 'px';
      pCanvas.style.height = window.innerHeight + 'px';
      pCtx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
    }
    resizePreludeCanvas();
    window.addEventListener('resize', resizePreludeCanvas);

    // Mobile optimisation: cap pixel ratio for main canvas (performance), but use full DPR for text
    const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const DPR = IS_MOBILE ? Math.min(window.devicePixelRatio || 1, 2) : (window.devicePixelRatio || 1);
    const TEXT_DPR = window.devicePixelRatio || 1; // full DPR for sharp text on retina

    let W = 0;
    let H = 0;
    let cx = 0;
    let cy = 0;
    let sc = 0;

    // Minimal controls: only delay + speed for each animation block.
    // Wire CONFIG into ANIM (used throughout the engine)
    const ANIM = {
      contour: {
        delay: CONFIG.contour.startAt,
        speed: CONFIG.contour.speed,
        glow: CONFIG.contour.glow,
      },
      network: {
        delay: CONFIG.network.startAt,
        speed: 5,
        bfsSpeed: CONFIG.network.bfsSpeed,
      },
      words: {
        delay: CONFIG.iLoveYou.startAt,
        speed: 1,
      },
      line: { delay: 0.5, speed: 0.05 },
      sweep: { delay: -7, speed: 40, sweepSpeed: 7 },
      preludeFirst: {
        delay: CONFIG.prelude1.startAt,
        speed: 1,
        wordDelay: 0,
        part1HideAfter: CONFIG.prelude1.holdPart1,
        part2ShowAfter: CONFIG.prelude1.overlapPart2,
        part2HideAfter: CONFIG.prelude1.holdPart2,
      },
      preludeSecond: {
        delay: CONFIG.prelude2.startAt,
        speed: 1,
        wordDelay: 0,
        part1HideAfter: CONFIG.prelude2.holdPart1,
        part2ShowAfter: CONFIG.prelude2.overlapPart2,
        part2HideAfter: CONFIG.prelude2.holdPart2,
      },
      iLoveYou: { baseDelay: 0 },
      main: {
        delay: CONFIG.global.mainStartAt,
        speed: CONFIG.global.mainSpeed,
      },
    };
    window.ANIM = ANIM;

    const INTERIOR_COUNT = IS_MOBILE ? 340 : CONFIG.network.particleCount;
    const CONTOUR_COUNT = IS_MOBILE ? 180 : CONFIG.network.contourCount;
    const BIRTH_DUR = 0.25 / Math.max(0.1, ANIM.contour.speed);
    const SPRING = 10.5;
    const DAMPING = 0.86;
    const CONTOUR_START = ANIM.contour.delay;
    const CONTOUR_STEP = 0.012 / Math.max(0.1, ANIM.contour.speed);
    const INTERIOR_START = 1.35;
    const CONTOUR_LINE_ALPHA = 0.62;

    const particles = [];
    const boundary = [];
    let heartClipPath = null;
    const links = [];
    const LINK_DIST = CONFIG.network.linkDist;
    const LINK_DIST_SQ = LINK_DIST * LINK_DIST;
    const MIN_LINKS_PER_NODE = 2;
    const MAX_LINKS_PER_NODE = 6;
    const LINK_ALPHA_SMOOTH = 9;
    const LINK_WOBBLE = 4.5;
    const LINK_FLOW_SPEED = 9.0;
    const LINK_DRIFT = 2.4;
    const DEPTH_POINT_SCALE = [0.72, 1.0, 1.42];
    const DEPTH_POINT_ALPHA = [0.45, 0.95, 1.32];
    const DEPTH_GLOW_ALPHA = [0.05, 0.15, 0.34];
    const DEPTH_LINK_ALPHA = [0.46, 1.02, 1.48];
    const DEPTH_LINK_WIDTH = [0.72, 1.08, 1.5];
    let contourStartIndex = 0;
    const BND_FIXED = [];
    let BND_TOP_IDX = 0;

    // ── PULSE HEART ──────────────────────────────────────────────────
    const PULSE_INTERVAL = CONFIG.pulse.interval;
    const PULSE_BEAT_DUR = CONFIG.pulse.beatDur;
    let pulseBeats = [];   // { time: animElapsed when beat fired }
    let lastBeatTime = -999;
    let pulseActive = false;

    function pickDepthLayer() {
      const r = Math.random();
      if (r < 0.34) return 0; // far
      if (r < 0.77) return 1; // mid
      return 2; // front
    }

    function hx(t) {
      return 16 * Math.pow(Math.sin(t), 3);
    }

    function hy(t) {
      return -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
    }

    function resize() {
      const cssW = window.innerWidth;
      const cssH = window.innerHeight;
      W = canvas.width = Math.round(cssW * DPR);
      H = canvas.height = Math.round(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      cx = cssW / 2;
      cy = cssH / 2 - 70;
      // Heart formula spans ±16 units wide and ~18 units tall.
      // Cap sc so the heart fits within the screen with some padding.
      const scByW = (cssW * 0.46) / 16;
      const scByH = (cssH * 0.44) / 18;
      sc = Math.min(scByW, scByH);
      buildHeart();
      resetAnimation();
    }

    function buildHeart() {
      boundary.length = 0;
      const HEART_SEGMENTS = 900;
      for (let i = 0; i < HEART_SEGMENTS; i++) {
        const t = (i / HEART_SEGMENTS) * Math.PI * 2;
        boundary.push({ x: cx + hx(t) * sc, y: cy + hy(t) * sc });
      }

      // Fixed boundary for stable contour drawing (not affected by particle movement)
      BND_FIXED.length = 0;
      for (let i = 0; i < boundary.length; i++) BND_FIXED.push({ x: boundary[i].x, y: boundary[i].y });
      // BND_TOP_IDX is set after contourStartIndex is computed below
      heartClipPath = new Path2D();
      heartClipPath.moveTo(boundary[0].x, boundary[0].y);
      for (let i = 1; i < boundary.length; i++) {
        heartClipPath.lineTo(boundary[i].x, boundary[i].y);
      }
      heartClipPath.closePath();

      particles.length = 0;

      // ── Deterministic seeded RNG (mulberry32) ──────────────────────
      // Same seed every run → fixed particle positions across reloads.
      let _seed = 0xDEADBEEF;
      function srng() {
        _seed |= 0; _seed = _seed + 0x6D2B79F5 | 0;
        let z = Math.imul(_seed ^ (_seed >>> 15), 1 | _seed);
        z = z + Math.imul(z ^ (z >>> 7), 61 | z) ^ z;
        return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
      }

      // ── Place particles near the contour (ring zone) ───────────────
      // Each particle is placed at a random angle on the heart curve,
      // then pulled inward by a small random offset so it never touches
      // the contour but stays close to it.
      const NEAR_MIN = CONFIG.network.nearMin;
      const NEAR_MAX = CONFIG.network.nearMax;

      const pairCount = Math.floor(INTERIOR_COUNT / 2);
      for (let i = 0; i < pairCount; i++) {
        const t = srng() * Math.PI * 2;
        const r = NEAR_MIN + srng() * (NEAR_MAX - NEAR_MIN);
        const sx = hx(t) * sc * r;
        const txR = cx + Math.abs(sx);
        const txL = cx - Math.abs(sx);
        const ty = cy + hy(t) * sc * r;
        const spawnAt = srng() * WAVE_DUR;
        const size = 1.05 + srng() * 1.35;
        const phase = srng() * Math.PI * 2;
        const pulse = 0.5 + srng() * 0.9;
        // Depth: points near contour are mostly front-layer
        const dRoll = srng();
        const depth = dRoll < 0.18 ? 0 : dRoll < 0.52 ? 1 : 2;

        particles.push({
          x: txR, y: ty, tx: txR, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false, size, phase, pulse, mirrorSign: 1, depth
        });

        particles.push({
          x: txL, y: ty, tx: txL, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false, size, phase, pulse, mirrorSign: -1, depth
        });
      }

      if (INTERIOR_COUNT % 2 === 1) {
        const t = srng() * Math.PI * 2;
        const r = NEAR_MIN + srng() * (NEAR_MAX - NEAR_MIN);
        const tx = cx;
        const ty = cy + hy(t) * sc * r;
        const spawnAt = srng() * WAVE_DUR;
        particles.push({
          x: tx, y: ty, tx, ty,
          vx: 0, vy: 0, alpha: 0, born: false, bornTime: 0,
          spawnAt, isContour: false,
          size: 1.1 + srng() * 1.15,
          phase: srng() * Math.PI * 2,
          pulse: 0.55 + srng() * 0.8,
          mirrorSign: 0, depth: 1
        });
      }

      // Build contour points with uniform arc-length spacing.
      const closed = boundary.slice();
      closed.push(boundary[0]);
      const cumulative = new Array(closed.length).fill(0);
      for (let i = 1; i < closed.length; i++) {
        const dx = closed[i].x - closed[i - 1].x;
        const dy = closed[i].y - closed[i - 1].y;
        cumulative[i] = cumulative[i - 1] + Math.hypot(dx, dy);
      }
      const totalLen = cumulative[cumulative.length - 1] || 1;

      let seg = 1;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const targetLen = (i / CONTOUR_COUNT) * totalLen;
        while (seg < cumulative.length - 1 && cumulative[seg] < targetLen) seg++;

        const l0 = cumulative[seg - 1];
        const l1 = cumulative[seg];
        const t = l1 > l0 ? (targetLen - l0) / (l1 - l0) : 0;
        const a = closed[seg - 1];
        const b = closed[seg];
        const tx = a.x + (b.x - a.x) * t;
        const ty = a.y + (b.y - a.y) * t;

        particles.push({
          x: tx,
          y: ty,
          tx,
          ty,
          vx: 0,
          vy: 0,
          alpha: 0,
          born: false,
          bornTime: 0,
          spawnAt: CONTOUR_START + i * CONTOUR_STEP,
          isContour: true,
          size: 1.25 + srng() * 0.95,
          phase: 0,
          pulse: 0,
          mirrorSign: 0,
          depth: 2
        });
      }

      // Find TOP notch of heart = minimum y near cx (the dip between the two lobes)
      // t = PI gives the bottom tip, t = PI/2 and t = 3PI/2 give the lobes
      // The notch between lobes is near t=0 where hx=0 and hy is local min
      // Find by scanning: smallest y value among contour particles near cx
      let bestNotchScore = Infinity;
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        // score = y value + penalty for being far from cx (finds top-center notch)
        const score = p.ty + Math.abs(p.tx - cx) * 1.5;
        if (score < bestNotchScore) {
          bestNotchScore = score;
          contourStartIndex = i;
        }
      }

      // Reveal contour symmetrically from the top notch to both sides.
      for (let i = 0; i < CONTOUR_COUNT; i++) {
        const p = particles[INTERIOR_COUNT + i];
        const cw = (i - contourStartIndex + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ccw = (contourStartIndex - i + CONTOUR_COUNT) % CONTOUR_COUNT;
        const ring = Math.min(cw, ccw);
        p.spawnAt = CONTOUR_START + ring * CONTOUR_STEP;
      }

      // Sync BND_TOP_IDX with contourStartIndex
      // The contour particle at contourStartIndex has target tx,ty — find closest BND_FIXED point
      {
        const refP = particles[INTERIOR_COUNT + contourStartIndex];
        let bstD = Infinity;
        for (let i = 0; i < BND_FIXED.length; i++) {
          const dx = BND_FIXED[i].x - refP.tx;
          const dy = BND_FIXED[i].y - refP.ty;
          const d = dx * dx + dy * dy;
          if (d < bstD) { bstD = d; BND_TOP_IDX = i; }
        }
      }

      initInteriorNetwork();
    }

    const WAVE_START = 0.3;
    const WAVE_DUR = 7.4 / Math.max(0.1, ANIM.network.speed);
    const NETWORK_START = ANIM.network.delay;
    const NETWORK_REVEAL_START = NETWORK_START + 0.1;
    const NETWORK_REVEAL_DUR = 0.85 / Math.max(0.1, ANIM.network.speed);

    // BFS wave data — populated in initInteriorNetwork after links are built
    const bfsOrder = [];        // particle indices in BFS visit order (interior only)
    const bfsParentOf = {};     // bfsParentOf[particleIdx] = parentParticleIdx
    const bfsTriggerTime = {};  // bfsTriggerTime[particleIdx] = animElapsed when ray arrives
    let bfsMaxDepth = 1;
    let bfsReady = false;
    // Total duration of the BFS wave spreading across the heart
    const BFS_TOTAL_DUR = 4.0 / Math.max(0.1, ANIM.network.bfsSpeed);
    // Active rays being drawn: { fromIdx, toIdx, startTime, dur, done }
    const activeRays = [];
    const TEXT_START = ANIM.words.delay;
    const NEON_SPEED = ANIM.sweep.speed;
    const NEON_TAIL_STEPS = 74;
    const NEON_TAIL_SPACING = 0.9;
    const CONTOUR_THREAD_ALPHA = 0.78;

    function ease(t) {
      return 1 - Math.pow(1 - Math.min(1, Math.max(0, t)), 3);
    }

    const txtEl = document.getElementById('txt');
    const wordEls = txtEl.querySelectorAll('.word');
    const preludeEl = document.getElementById('prelude');
    const preludeWords = preludeEl.querySelectorAll('.word');
    const prelude2El = document.getElementById('prelude2');
    const prelude2Words = prelude2El.querySelectorAll('.word');
    const introEl  = document.getElementById('intro');
    const startBtn = document.getElementById('startBtn');
    const disclaimerEl = document.getElementById('disclaimer');

    // Через 3с дисклеймер исчезает, появляется кнопка
    window.setTimeout(() => {
      disclaimerEl.classList.add('hiding');
      window.setTimeout(() => {
        disclaimerEl.style.display = 'none';
        startBtn.classList.add('visible');
      }, 600);
    }, 3000);
    const bgMusic = new Audio('music/post malone & swae lee - Sunflower (sped up + reverb).mp3');
    const wordBursts = [];
    const dustParticles = [];
    const DUST_PER_WORD = 95;
    const WORD_STAGGER = 0.42 / Math.max(0.1, ANIM.words.speed);
    const DUST_DUR = 1.05 / Math.max(0.1, ANIM.words.speed);
    const DUST_START_JITTER_MAX = 0.22 / Math.max(0.1, ANIM.words.speed);
    const DUST_LIFE_MAX_FACTOR = 1.12;
    const PRELUDE_WORDS_START_AT_SEC = ANIM.preludeFirst.delay;
    const PRELUDE2_WORDS_START_AT_SEC = ANIM.preludeSecond.delay;
    const MAIN_ANIMATION_START_AT_SEC = ANIM.main.delay;
    const LINE_AFTER_LAST_WORD_SEC = ANIM.line.delay;
    const LINE_IN_DUR_SEC = 0.85 / Math.max(0.1, ANIM.line.speed);
    const NEON_AFTER_LINE_SEC = ANIM.sweep.delay;
    const MAIN_TIME_SCALE = Math.max(0.2, ANIM.main.speed);

    let physicsAccumulator = 0;
    const PHYSICS_STEP = 1 / 60;
    let start = 0;
    let last = 0;
    let textStarted = false;
    let started = false;
    let startPending = false;
    let lineStartAt = Infinity;
    let contourNeonStartAt = Infinity;
    bgMusic.loop = false;
    bgMusic.volume = CONFIG.global.musicVolume;

    function resetAnimation() {
      start = Date.now();
      last = start;
      textStarted = false;
      lineStartAt = Infinity;
      contourNeonStartAt = Infinity;
      wordBursts.length = 0;
      dustParticles.length = 0;
      activeRays.length = 0;
      // Clear only runtime trigger times (re-scheduled each run), keep bfsParentOf (static tree)
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];
      txtEl.classList.remove('line-on');
      wordEls.forEach((w) => {
        w.classList.remove('visible', 'burst-in', 'burst-out', 'fog-in');
        w.style.animation = 'none';
        w.offsetHeight;
        w.style.animation = '';
      });
      // Reset SVG handwriting
      if (typeof ilySvg !== 'undefined') {
        ilySvg.innerHTML = '';
        ilyBuilt = false;
      }

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        // All particles stay at their target position — no "blooming from center" animation.
        // They appear in place via alpha fade (contour) or BFS chain reaction (interior).
        p.x = p.tx;
        p.y = p.ty;
        p.vx = 0;
        p.vy = 0;
        p.alpha = 0;
        p.born = false;
        p.bornTime = 0;
      }
    }

    // ── HANDWRITING "I LOVE YOU" ─────────────────────────────────────
    // Uses SVG <text> with stroke-dashoffset animation to simulate
    // a pen drawing each word. After drawing, a neon glow fades in.

    const ilySvg = document.getElementById('iloveyou-svg');
    // ── I LOVE YOU — Canvas рендер (надёжно на iOS Safari) ──────────
    // SVG stroke-dashoffset ненадёжен в Safari — используем Canvas + lineDash

    const ILY_WORDS = [
      { text: 'I', delaySec: 0.0 },
      { text: 'Love', delaySec: CONFIG.iLoveYou.delayLove },
      { text: 'You', delaySec: CONFIG.iLoveYou.delayYou }
    ];

    const ILY_DRAW_BASE = CONFIG.iLoveYou.drawSpeed;
    const ILY_GLOW_DUR = CONFIG.iLoveYou.glowDur;

    // Состояние каждого слова
    const ilyWords = ILY_WORDS.map(w => ({
      ...w,
      triggered: false,
      startTime: null,
    }));

    let ilyBuilt = false;
    let ilyFontSize = 0;
    let ilyY = 0;   // Y позиция текста на canvas (от верха экрана)
    let ilyLayout = [];  // [{text, x, pathLen, drawDur}]

    function buildIlySvg() {
      // скрываем SVG — рендерим на canvas
      ilySvg.style.display = 'none';
    }

    function buildIlyLayout() {
      if (ilyBuilt) return;
      ilyBuilt = true;

      const screenW = window.innerWidth;
      const screenH = window.innerHeight;

      ilyFontSize = Math.round(IS_MOBILE
        ? Math.max(32, Math.min(54, screenW * 0.058))
        : Math.max(42, Math.min(88, screenW * 0.078)));

      const off = document.createElement('canvas').getContext('2d');
      off.font = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
      const GAP = off.measureText(' ').width * 1.1;

      let ws = ILY_WORDS.map(w => ({ ...w, width: off.measureText(w.text).width }));
      let totalW = ws.reduce((s, w) => s + w.width, 0) + GAP * (ws.length - 1);

      // масштабируем если не влезает
      if (totalW > screenW * 0.92) {
        const scale = (screenW * 0.92) / totalW;
        ilyFontSize = Math.round(ilyFontSize * scale);
        off.font = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
        ws = ILY_WORDS.map(w => ({ ...w, width: off.measureText(w.text).width }));
        totalW = ws.reduce((s, w) => s + w.width, 0) + GAP * (ws.length - 1);
      }

      // Y — снизу экрана как в оригинале
      ilyY = screenH - ilyFontSize * 1.1;

      let curX = (screenW - totalW) / 2;
      ilyLayout = ws.map(w => {
        // Great Vibes — рукописный шрифт с завитками, реальный путь глифа
        // намного длиннее чем measureText. Используем щедрый множитель.
        // Для "I" особенно — у него завиток сверху и снизу.
        const charMultiplier = w.text === 'I' ? 10.0 : w.text === 'You' ? 9.0 : 6.0;
        const pathLen = Math.max(w.width * charMultiplier, ilyFontSize * w.text.length * 4.0);
        const drawDur = ILY_DRAW_BASE * (0.5 + w.text.length * 0.28);
        const x = curX + w.width / 2;
        curX += w.width + GAP;
        return { text: w.text, x, pathLen, drawDur };
      });
    }

    function drawIlyCanvas(elapsed) {
      if (!textStarted) return;
      buildIlyLayout();

      ctx.save();
      ctx.font = `400 ${ilyFontSize}px 'Great Vibes', cursive`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'alphabetic';

      ILY_WORDS.forEach((word, wi) => {
        const triggerAt = TEXT_START + word.delaySec;
        if (elapsed < triggerAt) return;

        const st = ilyWords[wi];
        if (!st.startTime) st.startTime = elapsed;

        const t = elapsed - st.startTime;
        const layout = ilyLayout[wi];
        if (!layout) return;

        const { x, pathLen, drawDur } = layout;

        // drawT: [0→1] прогресс рисования штриха
        const drawT = Math.min(1, t / drawDur);
        // glowT: начинает нарастать с glowSpeed% рисования — плавно перетекает
        const glowStart = 1 - CONFIG.iLoveYou.glowSpeed;
        const glowT = Math.min(1, Math.max(0, (drawT - glowStart) / (1 - glowStart)));
        // fadeIn: плавное появление в самом начале
        const fadeIn = Math.min(1, t / 0.25);
        const offset = pathLen * (1 - drawT);

        // Слой 0 — лёгкий широкий ореол
        ctx.globalAlpha = fadeIn * glowT * 0.12;
        ctx.lineWidth = 8;
        ctx.strokeStyle = 'rgba(255,80,150,1)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);

        // Слой 1 — средний розовый
        ctx.globalAlpha = fadeIn * glowT * 0.22;
        ctx.lineWidth = 3.5;
        ctx.strokeStyle = 'rgba(255,120,180,1)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);

        // Слой 2 — белое ядро
        ctx.globalAlpha = fadeIn * (0.75 + glowT * 0.25);
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(255,245,252,0.95)';
        ctx.setLineDash([pathLen, pathLen]);
        ctx.lineDashOffset = offset;
        ctx.strokeText(layout.text, x, ilyY);
      });

      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function startText(elapsed) {
      textStarted = true;
      const build = () => buildIlyLayout();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(build);
      } else {
        build();
      }

      const lastWord = ILY_WORDS[ILY_WORDS.length - 1];
      const lastDrawDur = ILY_DRAW_BASE * (0.7 + lastWord.text.length * 0.18);
      lineStartAt = elapsed + lastWord.delaySec + lastDrawDur + ILY_GLOW_DUR + 0.3;
      contourNeonStartAt = lineStartAt + LINE_IN_DUR_SEC + NEON_AFTER_LINE_SEC;
    }

    function updateAndDrawWordDust(elapsed) {
      drawIlyCanvas(elapsed);

      if (!txtEl.classList.contains('line-on') && elapsed >= lineStartAt) {
        txtEl.classList.add('line-on');
      }
    }

    function drawParticles() {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          if (p.alpha < 0.01 || p.depth !== layer) continue;

          if (p.isContour) continue; // drawn by neon line, not as dots
          const s = DEPTH_POINT_SCALE[layer];
          const a = p.alpha * DEPTH_POINT_ALPHA[layer];
          const g = p.alpha * DEPTH_GLOW_ALPHA[layer];

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * s, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${a})`;
          ctx.fill();

          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * (2.05 * s), 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255,50,130,${g})`;
          ctx.lineWidth = 0.35 + layer * 0.06;
          ctx.stroke();

          if (layer === 2) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * (3.25 * s), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255,50,130,${p.alpha * 0.22})`;
            ctx.lineWidth = 0.8;
            ctx.stroke();
          }
        }
      }
    }

    function drawVolumeFog(elapsed) {
      for (let layer = 0; layer <= 2; layer++) {
        for (let i = 0; i < INTERIOR_COUNT; i++) {
          const p = particles[i];
          if (p.depth !== layer || p.alpha < 0.04) continue;
          if ((i + layer) % 2 !== 0) continue;

          const fogPulse = 0.86 + Math.sin(elapsed * 1.4 + p.phase) * 0.14;
          const alpha = p.alpha * (0.025 + layer * 0.013) * fogPulse;
          const radius = p.size * (4.8 + layer * 1.25);

          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,40,120,${alpha})`;
          ctx.fill();
        }
      }
    }

    function clipToHeartShape() {
      if (!heartClipPath) return;
      ctx.clip(heartClipPath);
    }

    function initInteriorNetwork() {
      links.length = 0;
      const linkCounts = new Uint8Array(INTERIOR_COUNT);
      const grid = new Map();
      const cellSize = LINK_DIST;
      const edgeSet = new Set();

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const gx = Math.floor(p.tx / cellSize);
        const gy = Math.floor(p.ty / cellSize);
        const key = `${gx}|${gy}`;
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(i);
      }

      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        const gx = Math.floor(a.tx / cellSize);
        const gy = Math.floor(a.ty / cellSize);
        const candidates = [];

        for (let oy = -2; oy <= 2; oy++) {
          for (let ox = -2; ox <= 2; ox++) {
            const bucket = grid.get(`${gx + ox}|${gy + oy}`);
            if (!bucket) continue;
            for (let bi = 0; bi < bucket.length; bi++) {
              const j = bucket[bi];
              if (j === i) continue;

              const b = particles[j];

              const dx = a.tx - b.tx;
              const dy = a.ty - b.ty;
              const d2 = dx * dx + dy * dy;
              if (d2 > LINK_DIST_SQ) continue;
              candidates.push({ j, d2 });
            }
          }
        }

        candidates.sort((m, n) => m.d2 - n.d2);

        for (let ci = 0; ci < candidates.length; ci++) {
          if (linkCounts[i] >= MAX_LINKS_PER_NODE) break;
          const j = candidates[ci].j;
          if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

          const aIdx = i < j ? i : j;
          const bIdx = i < j ? j : i;
          const key = `${aIdx}|${bIdx}`;
          if (edgeSet.has(key)) continue;

          const d = Math.sqrt(candidates[ci].d2);
          const k = 1 - d / LINK_DIST;
          if (k < 0.025) continue;

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[j]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: 0, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // Ensure each interior particle has minimum links.
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const a = particles[i];
        while (linkCounts[i] < MIN_LINKS_PER_NODE) {
          let bestJ = -1;
          let bestD2 = Infinity;
          for (let j = 0; j < INTERIOR_COUNT; j++) {
            if (j === i) continue;
            const b = particles[j];
            if (linkCounts[j] >= MAX_LINKS_PER_NODE) continue;

            const aIdx = i < j ? i : j;
            const bIdx = i < j ? j : i;
            const key = `${aIdx}|${bIdx}`;
            if (edgeSet.has(key)) continue;

            const dx = a.tx - b.tx;
            const dy = a.ty - b.ty;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
            }
          }

          if (bestJ === -1) break;

          const aIdx = i < bestJ ? i : bestJ;
          const bIdx = i < bestJ ? bestJ : i;
          const key = `${aIdx}|${bIdx}`;
          const d = Math.sqrt(bestD2);
          const k = Math.max(0.2, 1 - d / (LINK_DIST * 1.8));

          edgeSet.add(key);
          linkCounts[i]++;
          linkCounts[bestJ]++;
          const depth = Math.round((particles[aIdx].depth + particles[bIdx].depth) * 0.5);
          links.push({ a: aIdx, b: bIdx, alpha: 0, targetAlpha: k, phase: Math.random() * Math.PI * 2, depth });
        }
      }

      // ── BFS from center particle ──────────────────────────────────────────
      // Build adjacency list for interior particles
      bfsOrder.length = 0;
      bfsReady = false;
      activeRays.length = 0;
      for (const k in bfsParentOf) delete bfsParentOf[k];
      for (const k in bfsTriggerTime) delete bfsTriggerTime[k];

      const adj = Array.from({ length: INTERIOR_COUNT }, () => []);
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        if (l.a < INTERIOR_COUNT && l.b < INTERIOR_COUNT) {
          adj[l.a].push(l.b);
          adj[l.b].push(l.a);
        }
      }

      // Find particle closest to heart center (cx, cy)
      let centerIdx = 0;
      let centerBestD2 = Infinity;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        const dx = p.tx - cx;
        const dy = p.ty - cy;
        const d2 = dx * dx + dy * dy;
        if (d2 < centerBestD2) { centerBestD2 = d2; centerIdx = i; }
      }

      // BFS
      const visited = new Uint8Array(INTERIOR_COUNT);
      const bfsQueue = [centerIdx];
      const bfsDepth = new Float32Array(INTERIOR_COUNT);
      visited[centerIdx] = 1;
      bfsParentOf[centerIdx] = -1;
      bfsOrder.push(centerIdx);
      let maxDepth = 0;
      let head = 0;
      while (head < bfsQueue.length) {
        const cur = bfsQueue[head++];
        const neighbors = adj[cur];
        for (let ni = 0; ni < neighbors.length; ni++) {
          const nb = neighbors[ni];
          if (visited[nb]) continue;
          visited[nb] = 1;
          bfsDepth[nb] = bfsDepth[cur] + 1;
          if (bfsDepth[nb] > maxDepth) maxDepth = bfsDepth[nb];
          bfsParentOf[nb] = cur;
          bfsQueue.push(nb);
          bfsOrder.push(nb);
        }
      }
      bfsMaxDepth = Math.max(1, maxDepth);
      // Store BFS depth on each particle for distance-based timing
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        particles[i].bfsDepth = bfsDepth[i];
      }
      // Center particle has no parent — it appears immediately
      bfsParentOf[centerIdx] = -1;
      bfsReady = true;
    }

    function updateInteriorNetwork(dt, elapsed) {
      if (!bfsReady) return;

      // Trigger particle birth when ray arrives
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (p.born) continue;
        if (bfsTriggerTime[i] === undefined) continue;
        if (elapsed >= bfsTriggerTime[i]) {
          p.born = true;
          p.bornTime = elapsed;
        }
      }

      // Update particle physics & alpha (interior particles: gentle float in place, no spring needed)
      const BIRTH_DUR_BFS = 0.30;
      for (let i = 0; i < INTERIOR_COUNT; i++) {
        const p = particles[i];
        if (!p.born) continue;

        p.alpha = ease((elapsed - p.bornTime) / BIRTH_DUR_BFS);

        // Gentle float animation around fixed position
        p.x = p.tx + Math.cos(elapsed * p.pulse * 2.2 + p.phase) * 1.8 * p.mirrorSign;
        p.y = p.ty + Math.sin(elapsed * (p.pulse * 2.0) + p.phase) * 1.8;
      }

      // Update link alphas
      const softDist = LINK_DIST * 1.35;
      for (let i = 0; i < links.length; i++) {
        const l = links[i];
        const a = particles[l.a];
        const b = particles[l.b];

        if (!a.born || !b.born) {
          l.targetAlpha = 0;
        } else {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          const distFactor = Math.max(0, 1 - d / softDist);
          l.targetAlpha = Math.min(a.alpha, b.alpha) * distFactor;
        }

        const t = Math.min(1, dt * LINK_ALPHA_SMOOTH);
        l.alpha += (l.targetAlpha - l.alpha) * t;
      }
    }

    // Called once per frame (not inside physics accumulator loop)
    function scheduleBfsRays(elapsed) {
      if (!bfsReady) return;
      const waveStart = NETWORK_START;

      for (let oi = 0; oi < bfsOrder.length; oi++) {
        const idx = bfsOrder[oi];
        const p = particles[idx];
        const parentIdx = bfsParentOf[idx];

        if (bfsTriggerTime[idx] !== undefined) continue; // already scheduled

        if (parentIdx === -1) {
          // Center particle: appears at waveStart
          bfsTriggerTime[idx] = waveStart;
        } else {
          if (bfsTriggerTime[parentIdx] === undefined) continue;

          const parentP = particles[parentIdx];
          const dx = p.tx - parentP.tx;
          const dy = p.ty - parentP.ty;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const rayDur = Math.max(0.08, (dist / (LINK_DIST * 1.2)) * (BFS_TOTAL_DUR / bfsMaxDepth));
          const arrivalTime = bfsTriggerTime[parentIdx] + rayDur;
          bfsTriggerTime[idx] = arrivalTime;

          activeRays.push({
            fromIdx: parentIdx,
            toIdx: idx,
            startTime: bfsTriggerTime[parentIdx],
            dur: rayDur,
            done: false
          });
        }
      }
    }

    function drawInteriorNetwork(elapsed) {
      const shimmer = 0.86 + Math.sin(elapsed * 2.2) * 0.14;

      // Batch by layer and pass to minimise draw calls:
      // Instead of 3 stroke() calls per link (= 3*N calls), we do 3 passes total.
      // Each pass strokes ALL visible links in one path per layer — 9 draw calls total.
      for (let layer = 0; layer <= 2; layer++) {
        const outerColor = layer === 0 ? '180,20,60' : layer === 1 ? '220,30,80' : '255,40,110';
        const mainColor = layer === 0 ? '200,30,70' : layer === 1 ? '235,50,100' : '255,60,130';
        const coreColor = layer === 0 ? '220,50,85' : layer === 1 ? '245,80,125' : '255,130,165';
        const depthAlpha = DEPTH_LINK_ALPHA[layer];
        const depthWidth = DEPTH_LINK_WIDTH[layer];
        const frontBoost = layer === 2 ? 1.16 : 1;

        // Collect visible links for this layer first
        const visible = [];
        for (let i = 0; i < links.length; i++) {
          const l = links[i];
          if (l.depth !== layer || l.alpha < 0.01) continue;
          visible.push(l);
        }
        if (visible.length === 0) continue;

        // Pass 1 — outer glow (widest)
        ctx.save();
        ctx.lineWidth = (1.95 + 0.16) * depthWidth * frontBoost;
        ctx.beginPath();
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l.alpha * shimmer * depthAlpha;
          const mx = (a.x + b.x) * 0.5;
          const my = (a.y + b.y) * 0.5;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const nx = -dy / len;
          const ny = dx / len;
          const wobble = Math.sin(elapsed * 3.8 + l.phase) * LINK_WOBBLE;
          const flow = 0.68 + Math.sin(elapsed * LINK_FLOW_SPEED + l.phase * 1.7) * 0.32;
          const drift = Math.cos(elapsed * 4.6 + l.phase * 1.3) * LINK_DRIFT;
          const tx2 = dx / len; const ty2 = dy / len;
          const cx2 = mx + nx * wobble + tx2 * drift;
          const cy2 = my + ny * wobble + ty2 * drift;
          // store per-link computed values for reuse in passes 2 & 3
          l._cx2 = cx2; l._cy2 = cy2; l._al = al; l._flow = flow;
          l._pulse = 0.72 + Math.sin(elapsed * 6.3 + l.phase * 2.4) * 0.28;
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
        }
        // Outer pass uses per-link alpha — must stroke individually (alpha varies per link)
        // But we can at least skip shadowBlur which is the heaviest cost
        ctx.restore();

        // Stroke individually but skip redundant state changes
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // Disable shadow for inner passes on mobile — saves ~40% GPU time
        if (!IS_MOBILE) { ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }
        for (let i = 0; i < visible.length; i++) {
          const l = visible[i];
          const a = particles[l.a];
          const b = particles[l.b];
          const al = l._al;
          const pulse = l._pulse;
          const flow = l._flow;
          const cx2 = l._cx2;
          const cy2 = l._cy2;

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${outerColor},${al * 0.28 * flow})`;
          ctx.lineWidth = (1.95 + pulse * 0.16) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${mainColor},${al * 0.5 * pulse})`;
          ctx.lineWidth = (1.2 + pulse * 0.14) * depthWidth * frontBoost;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.quadraticCurveTo(cx2, cy2, b.x, b.y);
          ctx.strokeStyle = `rgba(${coreColor},${al * 0.64 * flow})`;
          ctx.lineWidth = (0.84 + pulse * 0.1) * depthWidth * frontBoost;
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    function drawActiveRays(elapsed) {
      if (!bfsReady) return;
      ctx.save();
      ctx.lineCap = 'round';

      for (let i = activeRays.length - 1; i >= 0; i--) {
        const ray = activeRays[i];
        if (ray.done) continue;

        const t = (elapsed - ray.startTime) / ray.dur;
        if (t <= 0) continue;
        if (t >= 1.15) { ray.done = true; continue; }

        const progress = Math.min(1, t);
        const fromP = particles[ray.fromIdx];
        const toP = particles[ray.toIdx];

        // Interpolate ray tip position
        const tipX = fromP.x + (toP.x - fromP.x) * progress;
        const tipY = fromP.y + (toP.y - fromP.y) * progress;

        // Tail fades — ray is short, bright at tip, fading behind
        const tailLen = 0.35; // fraction of total distance shown as tail
        const tailT = Math.max(0, progress - tailLen);
        const tailX = fromP.x + (toP.x - fromP.x) * tailT;
        const tailY = fromP.y + (toP.y - fromP.y) * tailT;

        // Fade out as the ray completes (t > 1)
        const fadeOut = t > 1 ? 1 - (t - 1) / 0.15 : 1;
        const intensity = fadeOut * Math.min(1, progress * 3);

        // Outer glow
        const grd = ctx.createLinearGradient(tailX, tailY, tipX, tipY);
        grd.addColorStop(0, `rgba(255,80,140,0)`);
        grd.addColorStop(0.6, `rgba(255,120,180,${0.35 * intensity})`);
        grd.addColorStop(1, `rgba(255,255,255,${0.95 * intensity})`);

        ctx.shadowColor = 'rgba(255,80,160,0.9)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = grd;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Bright core
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(fromP.x + (toP.x - fromP.x) * Math.max(0, progress - 0.12), fromP.y + (toP.y - fromP.y) * Math.max(0, progress - 0.12));
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = `rgba(255,240,250,${0.98 * intensity})`;
        ctx.lineWidth = 1.0;
        ctx.stroke();

        // Bright tip dot
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.arc(tipX, tipY, 2.2 * intensity, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${intensity})`;
        ctx.fill();
      }

      ctx.restore();
    }

    function getContourPointCW(progress) {
      const start = INTERIOR_COUNT;
      const n = CONTOUR_COUNT;
      const wrapped = ((progress % n) + n) % n;
      const base = wrapped; // counter-clockwise direction
      const i0 = Math.floor(base) % n;
      const i1 = (i0 + 1) % n;
      const frac = base - Math.floor(base);
      const a = particles[start + i0];
      const b = particles[start + i1];
      return {
        x: a.x + (b.x - a.x) * frac,
        y: a.y + (b.y - a.y) * frac
      };
    }

    function drawContourThread(elapsed) {
      const contourStartAt = WAVE_START + CONTOUR_START;
      if (elapsed <= contourStartAt) return;
      const n = BND_FIXED.length; // 900
      if (n < 2) return;

      // Notch = i=0 (t=0, top center dip), Bottom = i=n/2 (t=PI, bottom tip)
      // Each arc covers exactly n/2 points — perfect symmetry
      const topIdx = 0;
      const half = Math.floor(n / 2); // 450

      const dur = CONTOUR_COUNT * CONTOUR_STEP;
      const progress = Math.min(1, Math.max(0, (elapsed - contourStartAt) / dur));
      if (progress <= 0) return;

      const visible = Math.round(progress * half); // same for both arcs

      // Unified breathing — same formula for both animation and completed states
      const glowStrength = Math.max(0.1, Math.min(1, ANIM.contour.glow));
      const breathe = (0.82 + Math.sin(elapsed * 2.4) * 0.18) * glowStrength;

      // Финальное неоновое свечение — плавно нарастает после finalGlowAt
      const finalT = elapsed > CONFIG.contour.finalGlowAt
        ? Math.min(1, (elapsed - CONFIG.contour.finalGlowAt) / CONFIG.contour.finalGlowSpeed)
        : 0;

      function drawNeonLine(pts, closed) {
        if (pts.length < 2) return;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Основные passes — не трогаем, как были
        const passes = IS_MOBILE ? [
          { blur: 14, color: `rgba(255,30,110,${0.22 * breathe})`, w: 7   },
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`, w: 2.2 },
          { blur: 1,  color: `rgba(255,80,140,${0.85 * breathe})`, w: 0.9 },
        ] : [
          { blur: 22, color: `rgba(255,40,110,${0.28 * breathe})`,  w: 11  },
          { blur: 11, color: `rgba(255,200,230,${0.45 * breathe})`, w: 5   },
          { blur: 5,  color: `rgba(255,50,120,${0.70 * breathe})`,  w: 2.2 },
          { blur: 2,  color: `rgba(255,80,140,${0.85 * breathe})`,  w: 0.9 },
        ];

        for (const p of passes) {
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          if (closed) ctx.closePath();
          ctx.shadowColor = 'rgba(220,20,70,1)';
          ctx.shadowBlur = p.blur;
          ctx.strokeStyle = p.color;
          ctx.lineWidth = p.w;
          ctx.stroke();
        }

        // Финальный неон — дополнительные слои поверх, нарастают плавно
        if (finalT > 0) {
          const pw = CONFIG.contour.finalGlowPower;
          const neonPasses = IS_MOBILE ? [
            { blur: 18, color: `rgba(255,20,100,${0.35 * finalT * pw})`,  w: 8   },
            { blur: 8,  color: `rgba(255,100,180,${0.55 * finalT * pw})`, w: 3   },
            { blur: 2,  color: `rgba(255,220,240,${0.7 * finalT})`,        w: 0.8 },
          ] : [
            { blur: 40, color: `rgba(255,0,80,${0.22 * finalT * pw})`,    w: 18  },
            { blur: 20, color: `rgba(255,40,120,${0.40 * finalT * pw})`,  w: 8   },
            { blur: 8,  color: `rgba(255,120,190,${0.60 * finalT * pw})`, w: 3   },
            { blur: 2,  color: `rgba(255,230,245,${0.80 * finalT})`,      w: 0.7 },
          ];
          for (const p of neonPasses) {
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            if (closed) ctx.closePath();
            ctx.shadowColor = 'rgba(255,0,100,1)';
            ctx.shadowBlur = p.blur;
            ctx.strokeStyle = p.color;
            ctx.lineWidth = p.w;
            ctx.stroke();
          }
        }

        ctx.restore();
      }

      if (progress >= 1) {
        // Full closed heart — same unified neon passes
        drawNeonLine(BND_FIXED, true);
        return;
      }

      // CW arc: 0 → 1 → 2 → ... → visible  (right side going down)
      const cwPts = [];
      for (let k = 0; k <= visible; k++) cwPts.push(BND_FIXED[k]);

      // CCW arc: 0 → n-1 → n-2 → ... → n-visible  (left side going down)
      // Skip index 0 (already in cwPts) to avoid double-rendering the notch point
      const ccwPts = [];
      for (let k = 1; k <= visible; k++) ccwPts.push(BND_FIXED[(n - k) % n]);

      // Draw as single merged path: ccw reversed + cw, so it's one continuous stroke from left tip → notch → right tip
      // This prevents the neon glow from stacking double at the starting notch point
      const mergedPts = [...ccwPts.slice().reverse(), ...cwPts];
      drawNeonLine(mergedPts, false);
    }



    // ── DRAW PULSING HEART IN CENTER ────────────────────────────────
    // ── ALINA — имя внутри сердца, та же анимация что I Love You ─────
    let alinaState = 'idle'; // idle → drawing → done
    let alinaStartTime = null;

    function drawPulseHeart(animElapsed) {
      if (!pulseActive) return;

      // Запускаем анимацию при первом вызове
      if (alinaState === 'idle') {
        alinaState = 'drawing';
        alinaStartTime = animElapsed;
      }

      const elapsed = animElapsed - alinaStartTime;

      // Параметры шрифта
      const fontSize = Math.round(Math.max(28, Math.min(64, sc * 2.8)));
      const font = `400 ${fontSize}px 'Great Vibes', cursive`;

      // Длина пути (приблизительно для "Alina")
      const pathLen = fontSize * 14;
      const drawDur = CONFIG.alina.drawSpeed;
      const glowDur = 0.8;

      // Прогресс рисования [0..1]
      const drawT = Math.min(1, elapsed / drawDur);
      const offset = pathLen * (1 - drawT);

      // После рисования — нарастание свечения
      const glowT = elapsed > drawDur ? Math.min(1, (elapsed - drawDur) / glowDur) : 0;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const fadeIn = Math.min(1, elapsed / 0.25);
      // glowT начинает нарастать согласно glowSpeed из CONFIG
      const glowStart = 1 - CONFIG.alina.glowSpeed;
      const glowT2 = Math.min(1, Math.max(0, (drawT - glowStart) / (1 - glowStart)));

      // Слой 0 — лёгкий широкий ореол
      ctx.globalAlpha = fadeIn * glowT2 * 0.10;
      ctx.lineWidth = 9;
      ctx.strokeStyle = 'rgba(255,80,150,1)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      // Слой 1 — средний розовый
      ctx.globalAlpha = fadeIn * glowT2 * 0.22;
      ctx.lineWidth = 4;
      ctx.strokeStyle = 'rgba(255,120,180,1)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      // Слой 2 — белое ядро
      ctx.globalAlpha = fadeIn * (0.8 + glowT2 * 0.2);
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(255,240,250,0.95)';
      ctx.setLineDash([pathLen, pathLen]);
      ctx.lineDashOffset = offset;
      ctx.strokeText('Alina', 0, 0);

      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // updatePulse и drawPulseFlash оставляем пустыми
    function updatePulse(animElapsed) { }
    function drawPulseFlash(animElapsed) { }

    function frame() {
      if (!started) return;
      const now = Date.now();
      const elapsed = (now - start) / 1000;
      const realDt = Math.min(0.1, (now - last) / 1000); // реальное время кадра, но не больше 100мс
      const animElapsed = elapsed * MAIN_TIME_SCALE;
      last = now;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // Accumulator: догоняем пропущенные шаги физики если кадр был тяжёлым
      physicsAccumulator += realDt;
      let steps = 0;
      while (physicsAccumulator >= PHYSICS_STEP && steps < 4) {
        const animDt = PHYSICS_STEP * MAIN_TIME_SCALE;

        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];

          // Interior particles are handled by updateInteriorNetwork (BFS wave)
          if (!p.isContour && i < INTERIOR_COUNT) continue;

          const baseStart = WAVE_START + p.spawnAt;
          const st = p.isContour
            ? baseStart
            : NETWORK_START + p.spawnAt;

          if (animElapsed >= st && !p.born) {
            p.born = true;
            p.bornTime = animElapsed;
          }

          if (!p.born) continue;

          p.alpha = ease((animElapsed - p.bornTime) / BIRTH_DUR);

          // Contour particles are fixed in place — no spring movement, appear via alpha only
          p.x = p.tx;
          p.y = p.ty;
        }

        updateInteriorNetwork(animDt, animElapsed);
        physicsAccumulator -= PHYSICS_STEP;
        steps++;
      }

      if (!textStarted && animElapsed >= TEXT_START) {
        startText(animElapsed);
      }

      // Schedule BFS rays once per frame (not in physics loop to avoid duplicates)
      scheduleBfsRays(animElapsed);

      // Activate alina name drawing
      if (!pulseActive && animElapsed > CONFIG.alina.startAt) {
        pulseActive = true;
        lastBeatTime = animElapsed - PULSE_INTERVAL; // fire first beat immediately
      }

      updatePulse(animElapsed);

      ctx.save();
      clipToHeartShape();
      drawVolumeFog(animElapsed);
      drawInteriorNetwork(animElapsed);
      drawPulseFlash(animElapsed);
      drawActiveRays(animElapsed);
      ctx.restore();
      drawParticles();
      drawContourThread(animElapsed);
      drawPulseHeart(animElapsed);
      updateAndDrawWordDust(animElapsed);
      requestAnimationFrame(frame);
    }

    // ── NEON OUTLINE PRELUDE ─────────────────────────────────────────
    // Words rendered as pure stroke (no fill) with layered neon glow.
    // Font: Raleway — thin for normal words, bold for accent.
    // Animation: word-by-word fade-in, breathing hold, fade-out.

    // Fonts already preloaded in <head>

    const NEON_FONT_NORMAL = () => `700 ${Math.round(Math.max(28, Math.min(58, window.innerWidth * 0.054)))}px 'Raleway', sans-serif`;
    const NEON_FONT_ACCENT = () => `700 ${Math.round(Math.max(38, Math.min(80, window.innerWidth * 0.07)))}px 'Raleway', sans-serif`;

    const FADE_IN_DUR = CONFIG.prelude1.fadeIn;
    const FADE_OUT_DUR = CONFIG.prelude1.fadeOut;
    const GLOW_PULSE = 4.6;

    let neonWords = [];
    let preludeStartTime = null;
    let preludeActive = false;
    let preludeRAF = null;

    function buildNeonWords() {
      neonWords = [];
      const pW = window.innerWidth;

      function collectLine(containerEl, part1Sel, part2Sel, cfg) {
        const part1Els = Array.from(containerEl.querySelectorAll(part1Sel));
        const part2Els = Array.from(containerEl.querySelectorAll(part2Sel));
        if (!part1Els.length) return;

        const maxP1DelayMs = Math.max(...part1Els.map(e => parseFloat(e.dataset.delay || 0)));
        const s = cfg.delay;
        const p1Hide = s + maxP1DelayMs / 1000 + cfg.part1HideAfter / 1000;
        const p2Show = p1Hide + cfg.part2ShowAfter / 1000;
        const p2Hide = p2Show + cfg.part2HideAfter / 1000;

        // Measure part1 words and compute X positions
        const off = document.createElement('canvas').getContext('2d');
        const fontN = NEON_FONT_NORMAL();
        const fontA = NEON_FONT_ACCENT();
        off.font = fontN;
        const GAP = off.measureText(' ').width * 0.9;

        const p1Texts = part1Els.map(e => e.textContent.trim());
        const p1W = p1Texts.map(t => { off.font = fontN; return off.measureText(t).width; });
        const p1Total = p1W.reduce((a, b) => a + b, 0) + GAP * (p1Texts.length - 1);

        // Y from DOM rect (element is invisible but laid out)
        const p1Rects = part1Els.map(e => e.getBoundingClientRect());
        const lineY1 = p1Rects.reduce((s2, r) => s2 + r.top + r.height / 2, 0) / p1Rects.length;

        let curX = pW / 2 - p1Total / 2;
        // fadeOutStart одинаковый для всей группы — все исчезают вместе
        const p1FadeOutStart = p1Hide - cfg.part1HideAfter / 1000 * 0.0 + (maxP1DelayMs / 1000);
        part1Els.forEach((el, i) => {
          const dMs = parseFloat(el.dataset.delay || 0);
          neonWords.push({
            text: p1Texts[i],
            font: fontN,
            isAccent: false,
            cx: curX + p1W[i] / 2,
            cy: lineY1,
            showAt: s + dMs / 1000,
            hideAt: p1Hide,
            fadeOutStart: p1Hide - cfg.part1HideAfter / 1000  // общий момент начала fadeOut
          });
          curX += p1W[i] + GAP;
        });

        // Part2 words (accent)
        if (part2Els.length) {
          const p2Texts = part2Els.map(e => e.textContent.trim());
          const p2W = p2Texts.map(t => { off.font = fontA; return off.measureText(t).width; });
          const p2Total = p2W.reduce((a, b) => a + b, 0) + GAP * (p2Texts.length - 1);
          const p2Rects = part2Els.map(e => e.getBoundingClientRect());
          const lineY2 = p2Rects.reduce((s2, r) => s2 + r.top + r.height / 2, 0) / p2Rects.length;
          let p2X = pW / 2 - p2Total / 2;
          part2Els.forEach((el, i) => {
            neonWords.push({
              text: p2Texts[i],
              font: fontA,
              isAccent: true,
              cx: p2X + p2W[i] / 2,
              cy: lineY2,
              showAt: p2Show,
              hideAt: p2Hide
            });
            p2X += p2W[i] + GAP;
          });
        }
      }

      collectLine(preludeEl, '.p1-part1', '.p1-part2', ANIM.preludeFirst);
      collectLine(prelude2El, '.p2-part1', '.p2-part2', ANIM.preludeSecond);
    }

    function drawNeonWord(word, alpha, elapsed) {
      if (alpha <= 0.005) return;
      pCtx.save();
      pCtx.imageSmoothingEnabled = true;
      pCtx.imageSmoothingQuality = 'high';
      pCtx.font = word.font;
      pCtx.textAlign = 'center';
      pCtx.textBaseline = 'middle';

      const pulse = 0.84 + Math.sin(elapsed * GLOW_PULSE + word.cx * 0.008) * 0.16;
      const gA = alpha * pulse;
      const isA = word.isAccent; // true for "You" and "Ever" only — pink neon
      // false for all other words — white neon

      if (isA) {
        // ── ACCENT: pink-magenta neon (You / Ever) ──────────────
        // Layer 1 — wide outer haze
        pCtx.shadowColor = 'rgba(255,0,130,1)';
        pCtx.shadowBlur = 55;
        pCtx.lineWidth = 3.5;
        pCtx.strokeStyle = `rgba(255,10,110,${gA * 0.38})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 2 — mid glow
        pCtx.shadowBlur = 24;
        pCtx.lineWidth = 2.5;
        pCtx.strokeStyle = `rgba(255,60,170,${gA * 0.72})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 3 — sharp neon edge
        pCtx.shadowBlur = 9;
        pCtx.lineWidth = 1.5;
        pCtx.strokeStyle = `rgba(255,100,200,${gA})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 4 — bright core hairline
        pCtx.shadowBlur = 2;
        pCtx.lineWidth = 0.5;
        pCtx.strokeStyle = `rgba(255,230,248,${alpha * 0.92})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

      } else {
        // ── NORMAL: pure white neon (all other words) ─────────────
        // Layer 1 — wide outer haze
        pCtx.shadowColor = 'rgba(255,255,255,1)';
        pCtx.shadowBlur = 40;
        pCtx.lineWidth = 2.6;
        pCtx.strokeStyle = `rgba(220,220,220,${gA * 0.25})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 2 — mid glow
        pCtx.shadowBlur = 18;
        pCtx.lineWidth = 1.9;
        pCtx.strokeStyle = `rgba(240,240,240,${gA * 0.55})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 3 — sharp white edge
        pCtx.shadowBlur = 7;
        pCtx.lineWidth = 1.1;
        pCtx.strokeStyle = `rgba(255,255,255,${gA})`;
        pCtx.strokeText(word.text, word.cx, word.cy);

        // Layer 4 — bright core hairline
        pCtx.shadowBlur = 2;
        pCtx.lineWidth = 0.5;
        pCtx.strokeStyle = `rgba(255,255,255,${alpha * 0.95})`;
        pCtx.strokeText(word.text, word.cx, word.cy);
      }

      pCtx.restore();
    }

    function drawPreludeFrame(now) {
      if (!preludeActive) return;
      const elapsed = (now - preludeStartTime) / 1000;
      pCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      for (const word of neonWords) {
        if (elapsed < word.showAt || elapsed > word.hideAt) continue;
        const fadeInT = Math.min(1, (elapsed - word.showAt) / FADE_IN_DUR);
        // fadeOutStart: общий для всей группы — все исчезают одновременно
        const foStart = word.fadeOutStart !== undefined ? word.fadeOutStart : (word.hideAt - FADE_OUT_DUR);
        const fadeOutT = Math.min(1, Math.max(0, (elapsed - foStart) / FADE_OUT_DUR));
        const eIn = 1 - Math.pow(1 - fadeInT, 3);
        const eOut = Math.pow(1 - fadeOutT, 2);
        drawNeonWord(word, eIn * eOut, elapsed);
      }

      preludeRAF = requestAnimationFrame(drawPreludeFrame);
    }

    function startPreludeAnimation() {
      requestAnimationFrame(() => {
        buildNeonWords();
        preludeStartTime = performance.now();
        preludeActive = true;
        preludeRAF = requestAnimationFrame(drawPreludeFrame);
      });
    }

    function stopPreludeAnimation() {
      preludeActive = false;
      if (preludeRAF) cancelAnimationFrame(preludeRAF);
      pCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }

    function startExperience() {
      if (started || startPending) return;
      startPending = true;

      // Разблокируем аудио сразу в момент tap — iOS требует play() в user gesture
      bgMusic.currentTime = 0;
      bgMusic.play().then(() => {
        bgMusic.pause(); // сразу ставим на паузу — запустим после эмодзи
      }).catch(() => { });

      introEl.classList.add('exiting');

      window.setTimeout(() => {
        if (started) return;
        introEl.classList.add('hidden');

        // Запускаем музыку после исчезновения эмодзи
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => { });

        // Start particle prelude
        startPreludeAnimation();

        // ── MAIN ANIMATION ─────────────────────────────────────
        const mainStartDelay = MAIN_ANIMATION_START_AT_SEC * 1000;
        window.setTimeout(() => {
          stopPreludeAnimation();
          started = true;
          resize();
          frame();
        }, mainStartDelay);
      }, 560);
    }

    window.addEventListener('resize', resize);
    startBtn.addEventListener('click', startExperience);

  </script>
</body>